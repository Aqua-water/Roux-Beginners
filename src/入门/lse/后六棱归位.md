<script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>

# 后六棱归位

## 目标

这步要**在色向还原的基础上**，将剩下的6个棱块彻底复原，从而完成整个魔方的复原。分为两个阶段：

先将左右面位于顶层的2个棱块复原，并将M层的中心块对齐，剩下最后M层的4个棱块。

<div id="l4e">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wlwwwwwlwgggggggggrlrrrrrlrylyyyyylybbbbbbbbbolooooolo')
    ('#l4e');
</script>
</div>

再复原最后4个棱块。

## 1 左右棱

### 左右棱置底

为了复原左右面位于顶层的2个棱块(ULUR)，我们先将要归位的黄蓝、黄绿棱块都放到底层。

以下是一个具体例子。你可以拖动魔方，主要查看底层的状态：

<div id="ulur">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wywwwwwywggggggglgrbrrrrrlrylylylylybbbbbbblbogooooolo')
    ('#ulur');
</script>
</div>

还原方法如下：

如果恰好有一个黄蓝或黄绿棱块在顶层：

先`Ux`将该棱块放在M层，并且保证其下方不是黄蓝或黄绿棱块。再做[基本操作五](./eo.md#基本操作五-m-u2-m)或[六](./eo.md#基本操作六-m-u2-m)，完成上下棱块的交换，将其放在底层。

这个例子通过基本操作六，将黄绿棱块从UR位移到DB位。

<div id="ulur-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wywwwwwywggggggglgrbrrrrrlrylylylylybbbbbbblbogooooolo')
    .case(`U' M U2 M'`)
    ('#ulur-1');
</script>
</div>

如果黄蓝、黄绿棱块都在顶层：

通过`Ux`将其中一个棱块放在M层，再`M2`将其放在底层。这样，至多有一个棱块仍然留在顶层，转化为上一种情形。

这个例子将黄绿棱块移到DB位，然后再通过基本操作五，将黄蓝棱块从UR位移到DF位。

<div id="ulur-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wlwwwwwlwgggggggbgrlrrrrrgryyylyyylybbbbbbblbolooooolo')
    .alg(`M2 U M' U2 M`)
    ('#ulur-2');
</script>
</div>

这样就将两个棱块都放在底层了，两个棱块谁在前并不重要，但色向必须正确。

### 左右棱归位

左右棱都放到底层后，做`Ux`调整顶层角块的姿态，然后做`M2`，将黄蓝、黄绿棱块分别与对应的角块合并。

<div id="ulur-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wywwwwwywggggggglgrbrrrrrlrylylylylybbbbbbblbogooooolo')
    .alg(`U M2`)
    ('#ulur-3');
</script>
</div>

最后做`Ux Mx`，将左右棱块与M层中心块彻底归位。

<div id="ulur-4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wlwwywwlwggggggolorlrrorgggyyylwlyyybbbbbbrlroloorobbb')
    .alg(`U' M2`)
    ('#ulur-4');
</script>
</div>

## 后四棱

这步完成最后4个棱块的复原（L4E）。

完成左右面的复原后，魔方的形态变得更加对称了。你可以自由地做一些[x转体](./../记号.md#x-转体)，也可以自由尝试一些M层操作与`U2`的组合。

下面介绍一些简单的4步操作，来完成魔方最终的复原。

###	三棱换

这种情况下，对齐中心块后，恰好有3个棱块未复原，而1个M层棱块已经复原。

首先做x转体，使复原的棱块位于DF位上。

下图中，我们将已复原的黄红棱块转到DF位上。

<div id="L4E">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wywwwwwwwgggggggggrorrrrrrryyyyyyywybbbbbbbbboooooooro')
    .alg(`x'`)
    ('#L4E');
</script>
</div>

进一步观察：

如果UF位的棱块颜色与两侧中心块的颜色都相反，做`U2 M U2 M'`（即`U2`+ 基本操作六）。

如图，UF位的白红棱块，两侧的中心块分别为黄、橙，满足要求。

<div id="L4E-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('rrrrrrrrrgggggggggyyyyyyyyyooooooooobbbbbbbbbwwwwwwwww')
    .case(`U2 M U2 M'`)
    ('#L4E-2');
</script>
</div>

如果UF位的棱块颜色仅与前面中心块的颜色相反，做`M U2 M' U2`（即基本操作六+`U2`）。

<div id="L4E-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('rrrrrrrrrgggggggggyyyyyyyyyooooooooobbbbbbbbbwwwwwwwww')
    .case(`M U2 M' U2`)
    ('#L4E-3');
</script>
</div>

你也可以尝试：如何不依赖转体，仅使用`U2`和M层操作的组合来复原。不转体的完整公式可参考[后四棱公式](./lse.md#后四棱公式)。

> 对于后四棱，有经验的桥式玩家不会依赖公式复原，而会通过提前观察相应的块的变化，完成对整个后四棱步骤的预判。这些观察方法包括4c入门观察法、DFDB观察法、BU观察法等。

### "H"

这种情况下，对齐中心块后，四个面已经复原，而剩余两个相对的面呈“H”型。将一个H型的面放在F面，做`U2 M2 U2 M2`。

<div id="L4E-4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('rrrrrrrrrgggggggggyyyyyyyyyooooooooobbbbbbbbbwwwwwwwww')
    .case(`x' U2 M2 U2 M2`)
    ('#L4E-4');
</script>
</div>

### 四心换

这种情况下，对齐中心块后，有四个面呈“H”型。做`E2 M' E2 M'`。

<div id="L4E-5">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`E2 M' E2 M'`)
    ('#L4E-5');
</script>
</div>

> 之所以笼统地称这类情况为“四心换”，是因为做`M2`后，除了4个中心块外的所有块都已复原。

至此，魔方的六面都已经复原，大功告成！

你可以反复练习，直到能够不依赖教程而独立复原。