<script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>

# 右桥

## 目标

右桥也是一个1×2×3的块，与左桥相同，而位置与左桥相对。其底色与左桥相同，桥色相反，因此需要完成一个**白底绿色桥**。

你可以通过下面的已经完成好的右桥，观察它与上节复原的左桥的联系。

<div id="inf1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    ('#inf1');
</script>

## 1 复原底层棱块

第一步是将将绿色中心块与绿白棱块合并、归位，并且不能破坏已经做好的左桥。

<div id="DR">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgttttrttrttttttttttttttbbbbbbtttttottottt')
    ('#DR');
</script>

如果绿白棱块已经和绿色中心块对齐，或绿白棱块在顶层且白色面朝上，通过 `Ux Rx`直接归位。

#### 例1: 直接归位的情形

<div id="DR1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwttttttgttttrttrttttttttttttwtbbbbbbtttttottotgt')
    .alg('U R2')
    ('#DR1');
</script>

如果不能通过上面的方法归位，就将绿白棱块转动到M层，并使棱块的白色面朝上，然后再做上述操作。下面给出两个例子。

#### 例2: 棱块在M层

转动`rx`或`Mx`即可。

<div id="DR2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwgtttttgttttrwtrttttttttttttttbbbbbbtttttottottt')
    .alg(`M' U' R2`)
    ('#DR2');
</script>

#### 例3：棱块不在M层

转动`Rx Ux`，将绿白棱块转动到M层；再做`rx`，使棱块的白色面朝上。

 <div id="DR3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttwgttttrttrtgttttttttttttbbbbbbtttttottottt')
    .alg(`R U r U R2`)
    ('#DR3');
</script>

## 2 复原第一个方块 (1x2x2)

 接下来要完成右桥中的一个 `1x2x2` 方块。可以使用`绿红-白`或`绿橙-白`棱角对，与已有的部分组合起来。

我们选择复原由`绿红-白`棱角对组成的方块，如图所示。

<div id="SS">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtwggtggttttrtrrtrttttttttttttbbbbbbtttttottottt')
    ('#SS');
</script>

我们介绍两类**基本操作**，以完成和右桥棱角对位置有关的块的处理：

#### 基本操作一：`R Ux R'`

这里的`Ux`可以是`U`、`U'`或`U2`。作用是将F、R层交界位置的两个块（灰色）移动到顶层。相应地，它们的位置也会被原本在顶层的两个块（黑色）替代。

 <div id="base1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttllttlttnttttlttlttnttnttttntttttttttttttttttnt')
    .alg(`R U R'`)
    ('#base1');
</script>

 <div id="base1-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttllttltttttttlttlnntnntttttttttttttttnttttttttt')
    .alg(`R U' R'`)
    ('#base1-2');
</script>

 <div id="base1-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttllttltttttttlttlttttttnttnttttttttnntttttttttn')
    .alg(`R U2 R'`)
    ('#base1-3');
</script>

#### 基本操作二：`R' Ux R`

与基本操作一类似，作用是将B、R层交界的两个块移动到顶层。

 <div id="base2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttlttttttttlttlttttttttttttttttttnntttttttnttlttltttnn')
    .alg(`R' U R`)
    ('#base2');
</script>

 <div id="base2-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttlttttttttlttlttntttttttnttnttttttntttttttttlttlttntt')
    .alg(`R' U' R`)
    ('#base2-2');
</script>

 <div id="base2-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttlttttttttlttltttttttttnttnttnttttttttttttnnlttlttttt')
    .alg(`R' U2 R`)
    ('#base2-3');
</script>

为了组好`绿红-白`棱角对并归位，我们采用以下步骤：

### 2-1 将棱块放至起始位

这一步的目标是将绿红棱块放在[起始位](./左桥.md#2-1-将棱块放至起始位)，不关心其朝向。和左桥相同，我们选择DF位作为起始位。

通过`Ux`将绿红棱块放在M层，然后做`Mx`，将棱块放入起始位。

<div id="DF">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgttgtrttrttttttttttrtttbbbbbbtttttottottt')
    .alg(`U M`)
    ('#DF');
</script>

#### 特例：棱块在右桥的位置上

如果棱块位于RF位或RB位，使用上面介绍的基本操作，将棱块移动到顶层，此时便位于M层了。

对于RB位，选择基本操作二。（为什么？请回忆基本操作的功能）

<div id="DF2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgrtttrttrttttttttttttttbbbbbbtttttogtottt')
    .alg(`R' U R M`)
    ('#DF2');
</script>

> 在左桥中，我们曾能够用`Fx`或`Bx`调整，将棱块移动到顶层。在右桥中不再适用。

### 2-2 调整角块色向

这一步的目标是调整绿红白角块的位置。目标是将绿红白角块放在顶层，并让白色面不朝上。

首先，将绿红白角块放在顶层。如果它不在顶层，那么一定在右桥位置上（RFD位或RBD位）。此时做一次基本操作即可。这里同样需要根据块的具体位置，以确定使用基本操作一还是二。在基本操作中，对`Ux`做适当的选择，可以避免做完后角块的白色面朝上的情况，从而一步到位。

<div id="DRF-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrgwgttgttttrgrrttttttttttttttbbbbbbtttttottottt')
    .alg(`R U R'`)
    ('#DRF-1');
</script>

同样的情形下，如果选择`U'`，将导致白色面朝上，需要额外做翻转。

<div id="DRF-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrgwgttgttttrgrrttttttttttttttbbbbbbtttttottottt')
    .alg(`R U' R'`)
    ('#DRF-2');
</script>

如果绿红白角块已经在顶层，且白色面朝上，那么需要调整角块的朝向。首先，转`Ux`将角块放在某个[翻转位](./左桥.md#特例2角块位于lfu位且白色面朝上)上。

如果在翻转位UFR位，做基本操作一中的`R U' R'`或`R U2 R'`。

<div id="DRF-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrttgttgttttrgtrttrttwttttttttbbbbbbttgttottottt')
    .alg(`U' R U' R'`)
    ('#DRF-3');
</script>

<div id="DRF-4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrttgttgttttrgtrttrttwttttttttbbbbbbttgttottottt')
    .alg(`U' R U2 R'`)
    ('#DRF-4');
</script>

如果在翻转位UBR位，做基本操作二中的`R' U R`或`R' U2 R`。

<div id="DRF-5">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrttgttgttttrgtrttrttwttttttttbbbbbbttgttottottt')
    .alg(`U2 R' U R`)
    ('#DRF-5');
</script>

> 在左桥中，我们曾能够用一步`Rx`完成角块翻转。在右桥中不再适用。

### 2-3 棱角对归位

这一步的目标是组好棱角对，并和已有的部分合并成方块。

首先做`Ux`，使白色面移到侧面（L面或R面），具体哪面视绿红棱块的朝向而定。其次做`Mx`，将棱角对正确合并。

<div id="pair">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrttgttgttttrgtrttgttrttttttttbbbbbbttwttottottt')
    .alg(`U2 M2`)
    ('#pair');
</script>

> 在左桥中，我们曾用`rx`或`Rx`，让角块移动。在右桥中，我们反过来让棱块移动，以迎合角块。

合并后有四种可能的情形。

#### 例1 基本操作一

<div id="pair1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgttttrttrttggtrrtttttttbbbbbbttwttottottt')
    .alg(`R U' R'`)
    ('#pair1');
</script>



#### 例2 类基本操作一

<div id="pair2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgtwttrttrtttrrtggttttttbbbbbbtttttottottt')
    .alg(`r U r'`)
    ('#pair2');
</script>

#### 例3 转化

`U2`转化为例1。另有一种情形同理转化为例2，不再列举。

<div id="pair3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgtttwrttrttttttttttttrrbbbbbbtttttottoggt')
    .alg(`U2'`)
    ('#pair3');
</script>



## 3 复原剩余棱角对

接下来将复原剩余一对棱角对，完成右桥构建。在这里，我们需要复原`绿橙-白`棱角对。

和左桥一样，这步可以套用第一组棱角对的做法。

### 3-1 将棱块放至起始位

将绿橙棱块放在起始位，即`DF位`。

<div id="DF3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtwggtgggttgrtrrtrtttttttttttobbbbbbtttttootowtt')
    .alg(`R' U R M`)
    ('#DF3');
</script>

###  3-2 调整角块色向

将绿橙白角块放在顶层，并让白色面不朝上。仍然使用了“翻转位”的方法。

> 与复原第一组棱角对不同的是，此时前棱角对已归位，那么应该避免选择基本操作一，因为它会破坏这组棱角对的位置。因此这时翻转位只能选择UBR位，并做基本操作二。同理，如果是先复原后面那组棱角对，那么要避免做基本操作二。

<div id="DRF-6">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwgwggtggttttrorrtrgttwttttttttbbbbbbttottottottt')
    .alg(`U2 R' U R`)
    ('#DRF-6');
</script>

###  3-3 棱角对归位

组好棱角对并归位。

<div id="DRF-7">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwgwggtggttttrorrtrottgttttttttbbbbbbttwttottottt')
    .alg(`U2 M2 r' U' r`)
    ('#DRF-7');
</script>

> 棱角对正确合并后，这里出现的情形和[类基本操作一](#例2-类基本操作一)互为镜像，因此解法也是镜像的：`r`与`r'`对称，`U`与`U'`对称。

更多的情形请自行尝试。

顺带一提，在后续的“后六棱”步骤中，将要求顶层的中心块为黄色或白色。右桥复原的最后一次转动中，你可以自由选择转`Rx`还是`rx`，以归位最后一对棱角对，因此上述目标在右桥最后一步中就可完成，从而避免后续通过`Mx`再次调整。
