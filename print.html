<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>桥式教程</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">桥式教程</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>欢迎来到桥式解法的世界！无论你是魔方初学者，还是已经有了一定基础（如层先法、CFOP）的玩家，学习桥式方法都是不错的选择。</p>
<p>本教程分为两部分：第一部分面向零基础入门者，第二部分则面向已掌握魔方原理的中级玩家。</p>
<p>桥式解法蕴含着一些独特的复原思路，因此即便你最终没有选择桥式解法作为主力解法，桥式有关的知识仍然会对提升你的解法有益处。</p>
<h2 id="桥式"><a class="header" href="#桥式">桥式</a></h2>
<p>在一切开始之前，先简单认识一下桥式解法吧：</p>
<blockquote>
<p>如果你对魔方的基本知识还不熟悉，可以先阅读<a href="./beginners/%E5%85%A5%E9%97%A8.html">入门</a>与<a href="./beginners/%E8%AE%B0%E5%8F%B7.html">记号</a>。</p>
</blockquote>
<p>桥式(Roux)解法是三阶魔方的一种复原方法，以其发明者Gilles Roux（法国）的名字命名。2003年夏天，Roux在学习CFOP解法时被其繁杂的公式困扰，决心发明一种简单高效的解法。经Roux本人和其他众多魔方爱好者的完善，桥式解法逐渐发展为一种成熟的速拧方法。它的特点是还原步数少、转体少、在最后一步（后六棱）中大量使用 M 层转动，在单手项目上有独特的优势。</p>
<p>桥式解法分为左桥（FB, First Block）、右桥（SB, Second Block）、四角归位(CMLL)、后六棱(LSE, Last Six Edges)4个步骤。</p>
<h3 id="左桥"><a class="header" href="#左桥">左桥</a></h3>
<p>复原一个1×2×3的块（左桥）。</p>
<div id="FB">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    ('#FB');
</script>
<h3 id="右桥"><a class="header" href="#右桥">右桥</a></h3>
<p>复原另一个1×2×3的块（右桥），位置与已有的左桥相对。</p>
<div id="SB">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    ('#SB');
</script>
<h3 id="cmll"><a class="header" href="#cmll">CMLL</a></h3>
<p>复原顶层的四个角块的朝向和相对位置。</p>
<div id="CMLL">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwgggggggtgrtrrtrrtrytytttytybbbbbbbtbotootooto')
    ('#CMLL');
</script>
</div>
<h3 id="后六棱"><a class="header" href="#后六棱">后六棱</a></h3>
<p>复原最后六个棱块，即位于顶层的左右两侧各一个棱块，以及M层的四个棱块。</p>
<div id="LSE">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    ('#LSE');
</script>
</div>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="入门"><a class="header" href="#入门">入门</a></h1>
<p>本教程旨在为零基础的学习者介绍如何使用桥式解法复原三阶魔方，因此首先介绍魔方的基本知识。</p>
<blockquote>
<p>本节的内容可能非常简单。但如果你对魔方的转动记号并不十分熟悉，请不要跳过<a href="%E5%85%A5%E9%97%A8/./beginners/%E8%AE%B0%E5%8F%B7.html">记号</a>一节。使用教程提供的互动魔方，会对准确理解每类转动很有帮助。</p>
</blockquote>
<h2 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h2>
<p>你现在手中拿着的魔方被称为<strong>三</strong>阶魔方，因为它呈立方体形状，且每一条棱上包含三个块。三阶魔方的块分为三类：</p>
<ol>
<li>角块
<ul>
<li>角块拥有3个面，出现在立方体的每个顶点上，总共有8个。</li>
<li>无论怎样打乱魔方，角块的三个面之间的相对位置不会变化。</li>
</ul>
</li>
<li>棱块
<ul>
<li>棱块拥有2个面，出现在立方体的每条棱的中央，总共有12个。</li>
<li>无论怎样打乱魔方，不同类型的块不会相互转换。例如，角块不可能移动到棱块的位置上去。</li>
</ul>
</li>
<li>中心块
<ul>
<li>中心块拥有1个面，出现在立方体的每个面的中央，总共有6个。</li>
<li>无论如何打乱魔方，中心块的相对位置不会变化。例如，在<strong>标准配色</strong>下，白色中心块的对面一定是黄色中心块。</li>
</ul>
</li>
</ol>
<p>这三类块构成了立方体表面上所有的26个块。</p>
<h2 id="标准配色"><a class="header" href="#标准配色">标准配色</a></h2>
<p>请检查你手中的魔方是否是标准配色，这是本教程能够顺利指导复原的前提。方法是观察各个面上的中心块，无论魔方是否为打乱状态。原则如下：</p>
<ol>
<li>
<p>白对黄（白色中心块的对面是黄色中心块）、蓝对绿、橙对红。</p>
</li>
<li>
<p>如果面朝黄、绿、红的三个中心块，它们将依次按顺时针排列。</p>
</li>
</ol>
<div id="color">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttttttttgttttttttrttttttttytttttttttttttttttttttt')
    .movePeriod(1000)
    ('#color');
</script>
<h2 id="尝试还原"><a class="header" href="#尝试还原">尝试还原</a></h2>
<p>你可以尝试自行复原魔方的一面：</p>
<div id="face">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttttttttttttttttttttttyyyyyyyyytttttttttttttttttt')
    .movePeriod(1000)
    ('#face');
</script>
<p>或者更进一步，一层：</p>
<div id="slice">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttttttttttgggttttttrrryyyyyyyyytttttttttttttttttt')
    .movePeriod(1000)
    ('#slice');
</script>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="记号"><a class="header" href="#记号">记号</a></h1>
<blockquote>
<p>使用 <a href="https://cubedb.net/">cubedb.net</a>，可以为你指定的转动序列生成最终的状态。</p>
</blockquote>
<h2 id="位置记号"><a class="header" href="#位置记号">位置记号</a></h2>
<p>一般来说，我们在复原中会选一个面对准自己。一旦视野中面积最大的面（称为“前“面）选定，并且魔方姿态正直，那么魔方的朝向也就确定了。视野中至多只能同时看见“前“面周围的两个面。</p>
<p>按照视野中各个面的不同朝向，采用以下记号来标记它们：</p>
<ol>
<li><code>顶</code>，或<code>U</code>（Up），有时也称为<code>上</code></li>
<li><code>前</code>，或<code>F</code>（Front）</li>
<li><code>右</code>，或<code>R</code>（Right）</li>
<li><code>底</code>，或<code>D</code>（Down，与<code>U</code>相对）</li>
<li><code>左</code>，或<code>L</code>（Left，与<code>R</code>相对）</li>
<li><code>后</code>，或<code>B</code>（Back，与<code>F</code>相对）</li>
</ol>
<p>在下图中的朝向中，中心块黄、红、绿、白、蓝、橙所对应的面，与上面介绍的各个朝向依次对应。</p>
<div id="faces">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttwttttttttgttttttttrttttttttyttttttttbttttttttotttt')
    ('#faces');
</script>
<p>由于棱块存在于两个面的交界处，因此使用两个面的记号也可以唯一表示棱块的位置。<code>UR位</code>指的是U面与R面交界的位置，在下图中为橙绿棱块。字母之间的顺序是随意的。</p>
<div id="edge-faces">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttttttttttgtttttttttttttttottttttttttttttttttttt')
    ('#edge-faces');
</script>
<p>处于同一位置的棱块，有两种不同的朝向可能。</p>
<div id="orientation">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttttttttttotttttttttttttttgttttttttttttttttttttt')
    ('#orientation');
</script>
<p>角块的位置也可同理表示。下图中的黄红绿棱块位于<code>URF位</code>。</p>
<div id="corner-faces">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttttttttttrttttttttttyttgttttttttttttttttttttttt')
    ('#corner-faces');
</script>
<h2 id="转动记号"><a class="header" href="#转动记号">转动记号</a></h2>
<p>试着转动魔方。魔方的所有6个面都可以转动，且每次转动都有一个面唯一对应。因此，转动记号可以沿用上节中的关于面的位置记号。</p>
<p>根据效果的不同，用三种记号来表示同一个面的转动：</p>
<ol>
<li>大写字母  （顺时针转动90°）</li>
<li>大写字母 + <code>'</code>  （逆时针转动90°）</li>
<li>大写字母 + <code>2</code>  （旋转180°）</li>
</ol>
<p>例如，<code>U</code>不仅表示顶面，也表示顶面按照顺时针旋转90°。<code>U'</code>则表示将顶面按照逆时针旋转90°。<code>U2</code>和<code>U’2</code>的效果相同，都是将顶面旋转180°。</p>
<p>使用下面的动画，点击中间的运行按键来熟悉每个转动记号，并且同时试着与你手中魔方的转动联系起来。</p>
<h3 id="u-转动"><a class="header" href="#u-转动">U 转动</a></h3>
<div id="U">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`U U' U2`)
    ('#U');
</script>
<h3 id="l-转动"><a class="header" href="#l-转动">L 转动</a></h3>
<div id="L">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`L L' L2`)
    ('#L');
</script>
<h3 id="f-转动"><a class="header" href="#f-转动">F 转动</a></h3>
<div id="F">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`F F' F2`)
    ('#F');
</script>
<h3 id="r-转动"><a class="header" href="#r-转动">R 转动</a></h3>
<div id="R">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`R R' R2`)
    ('#R');
</script>
<h3 id="b-转动"><a class="header" href="#b-转动">B 转动</a></h3>
<div id="B">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`B B' B2`)
    ('#B');
</script>
<h3 id="d-转动"><a class="header" href="#d-转动">D 转动</a></h3>
<div id="D">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`D D' D2`)
    ('#D');
</script>
<h3 id="转动序列"><a class="header" href="#转动序列">转动序列</a></h3>
<p>形如<code>R U R’ U’</code>的转动记号组合，代表依次进行对应的转动操作。</p>
<div id="RUR’U’">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`R U R' U'`)
    ('#RUR’U’');
</script>
<blockquote>
<p><code>B</code>层、<code>D</code>层和<code>L</code>层的转动方向也许有些特殊。注意所谓的顺逆时针，都是假定直接面向这个面的来观察的，而不是从你的视角的位置。例如，<code>D’</code>表示你从魔方底部向上看时，底层向逆时针旋转90°。<code>U’</code>和<code>D’</code>都代表逆时针旋转，但从你的角度来看，它们的转动方向是相反的。</p>
</blockquote>
<blockquote>
<p>注意转动记号取决于魔方当前的朝向，而不是对应中心块的颜色。如果红色中心块不在F面（前面），那么此时转动红色中心块所在面的记号就不再是<code>F</code>，而是由视野中它所在的面的朝向决定。它若在左边，那转动记号就是<code>L</code>。</p>
</blockquote>
<blockquote>
<p>应当逐步熟悉所有6类转动的手法，而不要依赖于先把要转动的面移动到自己面前，再去转这个面。即使这个面在视野之外（如转动<code>B’</code>），也不要改变魔方的朝向。</p>
</blockquote>
<h2 id="转体记号"><a class="header" href="#转体记号">转体记号</a></h2>
<p>转体就是魔方的整体转动。魔方可以通过三个基本的维度进行转体，因此使用所围绕的坐标轴来表示不同的转体。注意下面的<code>y</code>与<code>z</code>转动，与右手坐标系的y、z轴是相反的。</p>
<p>更简单的记忆方法是记住对应的面： <code>x</code>, <code>y</code>和 <code>z</code> 分别对应 <code>R</code>, <code>U</code>和 <code>F</code> 的方向。  例如，转体<code>x'</code> 和转动 <code>R'</code>类似，但是是所有的层都做相应转动，而不是只有R层转动。</p>
<h3 id="x-转体"><a class="header" href="#x-转体">x 转体</a></h3>
<div id="x">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`x x' x2`)
    ('#x');
</script>
<h3 id="y-转体"><a class="header" href="#y-转体">y 转体</a></h3>
<div id="y">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`y y' y2`)
    ('#y');
</script>
<h3 id="z-转体"><a class="header" href="#z-转体">z 转体</a></h3>
<div id="z">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`z z' z2`)
    ('#z');
</script>
<p>桥式解法将极少用到转体。</p>
<h2 id="其他对桥式学习有用的记号"><a class="header" href="#其他对桥式学习有用的记号">其他对桥式学习有用的记号</a></h2>
<p>使用转动和转体记号的组合，就足以表示所有的转动了。但也有一些组合转动，在桥式解法中会非常有用：<code>M</code>、<code>r</code>(或<code>Rw</code>）。<code>E</code>、<code>S</code>在特定情形下也许也会用到。</p>
<h3 id="m转动"><a class="header" href="#m转动">M转动</a></h3>
<p><code>M</code>层指的是L、R层中间的夹层，而<code>M</code>指的是将M层转动，而保持两边的层不动。<code>M</code>层转动非常能代表桥式解法的特色。<code>M</code>层转动对于顺逆时针的方向判断与<code>L</code>一致，较为反直觉，需要花时间适应。</p>
<blockquote>
<p>应当逐步练习一次性完成对<code>M</code>或<code>M’</code>的转动，不能用两次转动来代替。（为了<code>M</code>层转动的顺畅，建议使用一个好一些的魔方！）</p>
</blockquote>
<div id="M">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`M M' M2`)
    ('#M');
</script>
<h3 id="r转动"><a class="header" href="#r转动">r转动</a></h3>
<p><code>r</code>转动指的是在转动R层时，连带将M层转动。因此其顺逆时针的方向判断与<code>R</code>一致，但采用小写表示双层转动。注意<code>r</code>等价于转动<code>L</code>和转体<code>x</code>的叠加，不要混淆<code>r</code>与<code>L</code>。</p>
<div id="Rw">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`r r' r2`)
    ('#Rw');
</script>
<blockquote>
<p><code>Rw</code>记号通常用于高阶，但在三阶魔方中等价于<code>r</code>。<code>Rw</code>中的 <code>w</code> 代表的是 'wide'（宽）。如果在其他教程中遇到，知道它们是一回事就好。</p>
</blockquote>
<h3 id="不确定的转动"><a class="header" href="#不确定的转动">不确定的转动</a></h3>
<p>在本教程中，有时只能确定旋转哪一层，而具体旋转的效果要视情况而定。为了解决这类情况下表示的困难，约定采用"字母+<code>x</code>"来表示这类转动的集合。例如，用<code>Ux</code>来表示U层的所有可能转动，它可能是<code>U</code>、<code>U2</code>、<code>U’</code>，甚至<code>U0</code>（不转动）。同理有<code>Rx</code>、<code>Mx</code>、<code>rx</code>等。</p>
<h2 id="较冷门的记号"><a class="header" href="#较冷门的记号">较冷门的记号</a></h2>
<h3 id="e转动"><a class="header" href="#e转动">E转动</a></h3>
<p><code>E</code>层指的是U、D层中间的夹层，对应的转动为<code>E</code>转动。在桥式解法的最后一步中，有的玩家会使用双手<code>E</code>转动，处理一种称为“四心换”的情形。</p>
<div id="E">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`E E' E2`)
    ('#E');
</script>
<h3 id="s转动"><a class="header" href="#s转动">S转动</a></h3>
<p><code>S</code>层指的是F、B层中间的夹层，对应的转动为<code>S</code>转动。在单手处理“四心换”情形时，有的玩家会使用<code>S</code>转动代替<code>E</code>转动。</p>
<div id="S">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`S S' S2`)
    ('#S');
</script>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="左桥-1"><a class="header" href="#左桥-1">左桥</a></h1>
<h2 id="目标"><a class="header" href="#目标">目标</a></h2>
<p>左桥是一个1×2×3的块，其中2×3的面的颜色就称为这个桥的颜色，1×3的面的颜色称为这个桥的底的颜色。</p>
<p>左桥作为一个步骤，指的是把魔方左侧的1×2×3的块复原，作为桥式的第一步。左桥有24种可能的选择，但本教程将始终将白色底的蓝色桥作为待复原的左桥，并且后续的复原都以此为基础。</p>
<p>下面是一个白底蓝桥的形态，你可以拖动魔方以仔细观察。</p>
<div id="inf1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    ('#inf1');
</script>
<h2 id="左桥步骤"><a class="header" href="#左桥步骤">左桥步骤</a></h2>
<p>你可以借鉴复原一层的思路来复原左桥，例如先组好一部分十字，再插入对应角块，但仍然推荐你学习下面介绍的方法：不仅更加高效，而且可以应用在右桥的复原中。</p>
<h3 id="调整中心块朝向"><a class="header" href="#调整中心块朝向">调整中心块朝向</a></h3>
<p>这步只需旋转魔方，使得蓝色中心块位于左面。相应地，绿色中心块会位于右面。</p>
<p>此后需要保持这样的朝向不变——始终让蓝色中心块位于左面，直到魔方完全复原。</p>
<div id="centers">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttttttttgttttttttttttttttttttttttttbttttttttttttt')
    ('#centers');
</script>
<blockquote>
<p>只需调整蓝绿中心块的位置。在桥式的最后一步（后六棱）以前，其他中心块的位置不需要关心。</p>
</blockquote>
<h3 id="复原底层棱块"><a class="header" href="#复原底层棱块">复原底层棱块</a></h3>
<p>第一步是将蓝色中心块与蓝白棱块合并。合并后，蓝白棱块的蓝色面应当与蓝色中心块相邻，而白色面朝下。</p>
<div id="DL-0">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttttttttttttttttttttttttttbttbttttttttttttt')
    ('#DL-0');
</script>
<p>这步至多通过两次转动就能完成，以下是一些实例。</p>
<h5 id="例1-d层转动"><a class="header" href="#例1-d层转动">例1: D层转动</a></h5>
<div id="DL">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case('D2')
    ('#DL');
</script>
<h5 id="例2-l层转动"><a class="header" href="#例2-l层转动">例2: L层转动</a></h5>
<div id="DL-L2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case('L2')
    ('#DL-L2');
</script>
<h5 id="例3-未归位朝向错误"><a class="header" href="#例3-未归位朝向错误">例3: 未归位，朝向错误</a></h5>
<div id="DL-weird">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case(`B' D`)
    ('#DL-weird');
</script>
<h5 id="例4归位朝向错误"><a class="header" href="#例4归位朝向错误">例4：归位，朝向错误</a></h5>
<div id="DLflip">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case(`x F' D'`)
    ('#DLflip');
</script>
<p><code>或</code></p>
<div id="DLflip2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case(`D' r D'`)
    ('#DLflip2');
</script>
<p>(有很多可能的解法，请自行尝试。)</p>
<p>完成后，为了不改变蓝绿块的位置，此后我们不会轻易转动L层或D层。</p>
<h3 id="复原第一个方块-1x2x2"><a class="header" href="#复原第一个方块-1x2x2">复原第一个方块 (1x2x2)</a></h3>
<p>接下来要完成一个 <code>1x2x2</code> 方块。可以使用<code>蓝红-白</code>或<code>蓝橙-白</code>棱角对，与已有的部分组合起来。</p>
<p>以下是一个由<code>蓝红-白</code>棱角对组成的方块。</p>
<div id="square">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwttwtttttttttttrttrtttttttttttttttbbtbbtttttttttttt')
    ('#square');
</script>
<p>棱角对指的是一个棱块和一个复原状态下与之相邻的角块的组合。以下是一些已经组好的棱角对。</p>
<h5 id="蓝红-白"><a class="header" href="#蓝红-白">蓝红-白</a></h5>
<div id="pair1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttwtttttttttttrttrttttttttttttttttbttbtttttttttttt')
    ('#pair1');
</script>
<h5 id="蓝橙-白"><a class="header" href="#蓝橙-白">蓝橙-白</a></h5>
<div id="pair2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtttttttttttttttttttttttttttttttttttbttbtttttttottottt')
    ('#pair2');
</script>
<h5 id="蓝白-红"><a class="header" href="#蓝白-红">蓝白-红</a></h5>
<div id="pair3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwttwtttttttttttrttttttttttttttttttbbttttttttttttttt')
    ('#pair3');
</script>
<p>可以看出，位于蓝白桥两侧的棱角对，前面的棱角对的侧面颜色是红，而后面的棱角对对应橙。如果在复原过程中不清楚侧面的颜色，可以转动r层(<code>rx</code>)，将白色中心块与已复原的白底棱块对齐，再根据侧面的中心块颜色判断。</p>
<p>例如，根据中心块颜色可以看出，左桥为黄红桥时，前棱角对的侧面颜色是绿。</p>
<div id="pair4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttrrtttttttttttttttttgttttttttttttttyttyttttttttttttt')
    ('#pair4');
</script>
<blockquote>
<p>如前面所述，白色中心块不需要始终与白底棱块对齐，因为它接下来可能随着r层和M层转动而不断移动。</p>
</blockquote>
<p>为了复原<code>蓝红-白</code>棱角对，我们采用以下步骤：</p>
<h4 id="步骤1将棱块放至起始位"><a class="header" href="#步骤1将棱块放至起始位">步骤1：将棱块放至起始位</a></h4>
<p>起始位指的是是DF位，用黑色标出。</p>
<div id="DF">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttntttttttttttntttttttttttttttttbttbttttttttttttt')
    ('#DF');
</script>
<p>这一步的目标是将蓝红棱块放在起始位，不关心其朝向。步骤如下：</p>
<p>通过<code>Ux</code>、<code>Fx</code>或<code>Bx</code>，将蓝红棱块放在M层。随后做<code>rx</code>，将棱块放入起始位。</p>
<div id="DF-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwttttttttttttbtttttttttttttttrttttbttbttttttttttttt')
    .alg(`U r'`)
    ('#DF-1');
</script>
<blockquote>
<p>如果棱块已经位于M层，显然不需要通过<code>Ux</code>、<code>Fx</code>或<code>Bx</code>调整。<code>Ux</code>的说法包含了这个意思，因为<code>Ux</code>包含<code>U0</code>。随后的<code>rx</code>也同理。这种隐含的“如果已经完成，可直接跳过”的含义，在后面会遇到很多。</p>
</blockquote>
<h5 id="特例棱块处于dr位"><a class="header" href="#特例棱块处于dr位">特例：棱块处于DR位</a></h5>
<p>此时无法用上述流程解决，做<code>R F</code>即可。</p>
<div id="DF-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtbttttrttttttttttttttttttttttttttbttbttttttttttttt')
    .alg(`R F`)
    ('#DF-2');
</script>
<h4 id="步骤2调整角块色向"><a class="header" href="#步骤2调整角块色向">步骤2：调整角块色向</a></h4>
<p>这一步的目标是调整蓝红白角块的位置。目标是将蓝红白角块放在顶层，并让白色面不朝上。</p>
<p>大多数情况下，通过<code>Rx</code>或<code>Bx</code>一步就能完成。</p>
<div id="DLF-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttrwtttbtttwtttttttrtttttttttttttttttbttbttttbtttttttt')
    .alg(`B2`)
    ('#DLF-1');
</script>
<h5 id="特例1角块已经归位lfd位"><a class="header" href="#特例1角块已经归位lfd位">特例1：角块已经归位（LFD位）</a></h5>
<p>此时，无论怎样移动都会影响之前棱块的位置。此时做<code>r' F r</code>。</p>
<div id="DLF-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwttbbttttttttttwrtttttttttttttttttbrtbttttttttttttt')
    .alg(`r' F r`)
    ('#DLF-2');
</script>
<h5 id="特例2角块位于lfu位且白色面朝上"><a class="header" href="#特例2角块位于lfu位且白色面朝上">特例2：角块位于LFU位且白色面朝上</a></h5>
<p>此时，先转Ux将角块放在某个<strong>翻转位</strong>上。</p>
<p>翻转位指的是UFR位或UBR位，用黑色标出。</p>
<div id="flip">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttttntnttttttttnttntttttntbttbttttttttttttt')
    ('#flip');
</script>
<p>然后，作<code>R</code>或<code>R'</code>以翻转，将它放到另一个翻转位上，此时白色面便不在顶面上了。</p>
<div id="DLF-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttbtttttttttttrttttbttwtttttttttbttbtttrttttttttt')
    .alg(`U' R`)
    ('#DLF-3');
</script>
<p>或：</p>
<div id="DLF-4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttbtttttttttttrttttbttwtttttttttbttbtttrttttttttt')
    .alg(`U2' R'`)
    ('#DLF-4');
</script>
<h4 id="步骤3棱角对归位"><a class="header" href="#步骤3棱角对归位">步骤3：棱角对归位</a></h4>
<p>这一步的目标是组好棱角对，并和已有的部分合并成方块。</p>
<p>首先做<code>Ux</code>，使白色面移到侧面（L面或R面），具体哪面视蓝红棱块的朝向而定。其次做<code>rx</code>或<code>Rx</code>，将棱角对正确合并。最后通常能通过一步<code>F</code>或<code>F'</code>完成归位。</p>
<div id="pair5">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttbtttttttttttrttttrttbtttttttttbttbtttwttttttttt')
    .alg(`U2' R2 F`)
    ('#pair5');
</script>
<h5 id="特例不能直接f归位的情形"><a class="header" href="#特例不能直接f归位的情形">特例：不能直接F归位的情形</a></h5>
<div id="pair6">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttrtttttttttbtbtttttttttttttttrtbttbttttttttttwtt')
    .alg(`U' r2 U2 r' F`)
    ('#pair6');
</script>
<h3 id="复原剩余棱角对"><a class="header" href="#复原剩余棱角对">复原剩余棱角对</a></h3>
<p>接下来将复原剩余一对棱角对，完成左桥构建。在这里，我们需要复原<code>蓝橙-白</code>棱角对。</p>
<p>复原第一对棱角对的经验，可以几乎原封不动地用到第二组棱角对的复原中，因为它们只是关于前后做了镜像。通过下面的例子，你会看到如何用相同的办法复原<code>蓝橙-白</code>棱角对。</p>
<h4 id="步骤1将棱块放至起始位-1"><a class="header" href="#步骤1将棱块放至起始位-1">步骤1：将棱块放至起始位</a></h4>
<p>原本的<code>DF位</code>仍然作为起始位，不过这里选择了它的镜像位<code>DB位</code>。</p>
<div id="DB">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ottwttwtttttttttttrttrttttttttttttttwbbobbtttttbttbttt')
    .alg(`B' r`)
    ('#DB');
</script>
<h4 id="步骤2调整角块色向-1"><a class="header" href="#步骤2调整角块色向-1">步骤2：调整角块色向</a></h4>
<p>将蓝橙白角块放在顶层，并让白色面不朝上。仍然使用了“翻转位”的方法。</p>
<div id="DLB">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tbtwttwtttttttttttrttrtttttttttttwtttbbtbbotttottttttb')
    .alg(`U R'`)
    ('#DLB');
</script>
<h4 id="步骤3棱角对归位-1"><a class="header" href="#步骤3棱角对归位-1">步骤3：棱角对归位</a></h4>
<p>组好棱角对并归位。<code>Ux</code>+<code>rx</code>/<code>Rx</code> +<code>Bx'</code>能够处理大部分情况，与组第一组棱角对时的不同在于，最后的<code>Fx</code>换成了<code>Bx</code>。</p>
<div id="pair7">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tbtwttwttttttttbttrttrttttwttotttttttbbtbbttttottttttt')
    .alg(`U' R B'`)
    ('#pair7');
</script>
<p>更多的情形请自行尝试，注意复原时不要破坏已有的方块。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="右桥-1"><a class="header" href="#右桥-1">右桥</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmll-1"><a class="header" href="#cmll-1">CMLL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="后六棱-1"><a class="header" href="#后六棱-1">后六棱</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
