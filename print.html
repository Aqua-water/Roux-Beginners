<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>桥式教程</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-9dfbd86b.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-def39154.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">桥式教程</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <style>
    .mdbook-version {
        position: absolute;
        right: 20px;
        top: 60px;
        background-color: var(--theme-popup-bg);
        border-radius: 8px;
        padding: 2px 5px 2px 5px;
        border: 1px solid var(--theme-popup-border);
        font-size: 0.9em;
    }
</style>
<div class="mdbook-version">
最后更新: 2025.11.19
</div>

<script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>欢迎阅读这份桥式复原法入门教程！本教程假设读者此前没有了解过魔方有关的知识，另外也适合有一定基础（层先法、CFOP等方法）的玩家阅读。</p>
<p>桥式解法蕴含着一些独特的复原思路，因此即便你最终没有选择桥式解法作为主力解法，桥式有关的知识仍然会对提升你的解法有益处。</p>
<h2 id="桥式解法"><a class="header" href="#桥式解法">桥式解法</a></h2>
<p>在一切开始之前，先简单认识一下桥式解法吧：</p>
<p>桥式（Roux）解法是三阶魔方的一种复原方法，以其发明者Gilles Roux（法国）的名字命名。2003年夏，Roux在学习CFOP解法时被其繁杂的公式困扰，决心发明一种简单高效的解法。经Roux本人和其他众多魔方爱好者的完善，桥式解法逐渐发展为一种成熟的速拧方法。它的特点是还原步数少、转体少、公式少，并在最后一步（后六棱）中大量使用 M 层转动，在单手项目上有独特的优势。</p>
<p>所谓M层转动，指的是将左、右两面中间的夹层单独转动：</p>
<div id="M">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`M M' M2`)
    ('#M');
</script>
</div>

<p>桥式解法分为左桥（FB, First Block）、右桥（SB, Second Block）、四角归位(CMLL)、后六棱(LSE, Last Six Edges)4个步骤。</p>
<h3 id="左桥"><a class="header" href="#左桥">左桥</a></h3>
<p>复原一个1×2×3的块（左桥）。</p>
<div id="FB">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    ('#FB');
</script>
</div>

<h3 id="右桥"><a class="header" href="#右桥">右桥</a></h3>
<p>复原另一个1×2×3的块（右桥），位置与已有的左桥相对。</p>
<div id="SB">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    ('#SB');
</script>
</div>

<h3 id="cmll"><a class="header" href="#cmll">CMLL</a></h3>
<p>复原顶层的四个角块的朝向和相对位置。</p>
<div id="CMLL">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwgggggggtgrtrrtrrtrytytttytybbbbbbbtbotootooto')
    ('#CMLL');
</script>
</div>

<h3 id="后六棱"><a class="header" href="#后六棱">后六棱</a></h3>
<p>复原最后六个棱块，即位于顶层的左右两侧各一个棱块，以及M层的四个棱块。</p>
<div id="LSE">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    ('#LSE');
</script>
</div>

<h2 id="如何使用本教程"><a class="header" href="#如何使用本教程">如何使用本教程</a></h2>
<h3 id="虚拟魔方"><a class="header" href="#虚拟魔方">虚拟魔方</a></h3>
<p>本教程提供了大量的虚拟魔方演示，可以拖动以改变朝向；对于带有转动的演示，点击它们以执行转动（注意在第一次点击之前，它们显示的状态有可能是最终状态）。虚拟魔方的下方还有单步执行、恢复等选项，你可以自行探索。</p>
<p>建议使用电脑端阅读本教程，以更方便地观察这些虚拟魔方。如果使用手机端，尽量不要拖动虚拟魔方，因为拖动操作并不稳定；一些图片在竖屏下可能会变窄，可将手机切换为横屏阅读。</p>
<h3 id="复原步骤的阅读"><a class="header" href="#复原步骤的阅读">复原步骤的阅读</a></h3>
<p>本教程采用总分的结构，共有三章（不包括<a href="记号.html">记号</a>）。每一章的开头会介绍对应步骤的复原目标，并给出类似于纸质公式书的简略复原指引。每章下的小节则会详尽介绍对应步骤的做法。对于有一定基础或者理解能力强的读者，你可以只阅读章前的内容，而跳过小节中的详尽介绍。如果你已经完整学习了一遍，而忘记了某个情形的做法，有时也能通过章节开头的复原指引快速查阅。</p>
<p>桥式复原法中，每个阶段都有很多种可能的情形(case)，因此会涉及到分类讨论。在阅读每个小节时，你可以先像查字典一样，观察你手中的魔方对应的情形，确定应当按照教程中的哪一种方式复原，而不必一开始就逐句阅读。</p>
<p>第一次阅读时，你可以在完成一个步骤的复原后，直接跳到下个步骤，直至还原好你手中的魔方。经过多次的重复打乱和复原，你将逐渐学会应对每一种可能的情形。</p>
<p>如果某种情形难以通过打乱遇到，你可以使用<a href="#逆转动">反向转动</a>的方法得到这一情形。</p>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="入门"><a class="header" href="#入门">入门</a></h1>
<p>首先简单介绍魔方的基本知识。</p>
<blockquote>
<p>本节的内容可能非常简单。如果对魔方已经熟悉，你可以直接跳到<a href="#记号">记号</a>一节。</p>
</blockquote>
<h2 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h2>
<p>你现在手中拿着的魔方被称为<strong>三</strong>阶魔方，因为它呈立方体形状，且每一条棱上包含三个块。三阶魔方的块分为三类：</p>
<ol>
<li>角块
<ul>
<li>角块拥有3个面，出现在立方体的每个顶点上，总共有8个。</li>
<li>无论怎样打乱魔方，角块的三个面之间的相对位置不会变化。</li>
</ul>
</li>
<li>棱块
<ul>
<li>棱块拥有2个面，出现在立方体的每条棱的中央，总共有12个。</li>
<li>无论怎样打乱魔方，不同类型的块不会相互转换。例如，角块不可能移动到棱块的位置上去。</li>
</ul>
</li>
<li>中心块
<ul>
<li>中心块拥有1个面，出现在立方体的每个面的中央，总共有6个。</li>
<li>无论如何打乱魔方，中心块的相对位置不会变化。例如，在<strong>标准配色</strong>下，白色中心块的对面一定是黄色中心块。</li>
</ul>
</li>
</ol>
<p>这三类块构成了立方体表面上所有的26个块。</p>
<h2 id="标准配色"><a class="header" href="#标准配色">标准配色</a></h2>
<p>请检查你手中的魔方是否是标准配色，这是本教程能够顺利指导复原的前提。方法是观察各个面上的中心块，无论魔方是否为打乱状态。原则如下：</p>
<ol>
<li>
<p>白对黄（白色中心块的对面是黄色中心块）、蓝对绿、橙对红。</p>
</li>
<li>
<p>如果面朝黄、绿、红的三个中心块，它们将依次按顺时针排列。</p>
</li>
</ol>
<div id="color">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttttttttgttttttttrttttttttytttttttttttttttttttttt')
    .movePeriod(1000)
    ('#color');
</script>
</div>

<h2 id="尝试还原"><a class="header" href="#尝试还原">尝试还原</a></h2>
<p>你可以尝试自行复原魔方的一面：</p>
<div id="face">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttttttttttttttttttttttyyyyyyyyytttttttttttttttttt')
    .movePeriod(1000)
    ('#face');
</script>
</div>

<p>或者更进一步，一层：</p>
<div id="slice">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttttttttttgggttttttrrryyyyyyyyytttttttttttttttttt')
    .movePeriod(1000)
    ('#slice');
</script>
</div>

<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="记号"><a class="header" href="#记号">记号</a></h1>
<blockquote>
<p>本节的内容多且重要，但这不意味着你需要一次性记住。后续章节中出现记号时，往往伴随着虚拟魔方的转动演示，你可以将动画与记号对应起来。对于桥式解法，最重要的几个转动记号为<a href="#u-转动">U</a>、<a href="#f-转动">F</a>、<a href="#r-转动">R</a>、<a href="#m转动">M</a>与<a href="#r转动">r</a>。</p>
</blockquote>
<h2 id="位置"><a class="header" href="#位置">位置</a></h2>
<p>一般来说，我们在复原中会选一个面对准自己。一旦视野中面积最大的面（称为“前“面）选定，并且魔方姿态正直，那么魔方的朝向也就确定了。视野中至多只能同时看见“前“面周围的两个面。</p>
<p>按照视野中各个面的不同朝向，采用以下记号来标记它们：</p>
<ol>
<li><code>顶</code>，或<code>U</code>（Up），有时也称为<code>上</code></li>
<li><code>前</code>，或<code>F</code>（Front）</li>
<li><code>右</code>，或<code>R</code>（Right）</li>
<li><code>底</code>，或<code>D</code>（Down，与<code>U</code>相对）</li>
<li><code>左</code>，或<code>L</code>（Left，与<code>R</code>相对）</li>
<li><code>后</code>，或<code>B</code>（Back，与<code>F</code>相对）</li>
</ol>
<p>在下图中的朝向中，中心块黄、红、绿、白、蓝、橙所对应的面，与上面介绍的各个朝向依次对应。注意在本节中，请勿改变所有虚拟魔方的初始朝向，否则记号无法与演示对应。</p>
<div id="faces">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttwttttttttgttttttttrttttttttyttttttttbttttttttotttt')
    ('#faces');
</script>
</div>

<p>由于棱块存在于两个面的交界处，因此使用两个面的记号也可以唯一表示棱块的位置。<code>UR位</code>指的是U面与R面交界的位置，在下图中为橙绿棱块。这里只表示块的位置而不表示朝向，因此字母之间的顺序是随意的。</p>
<div id="edge-faces">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttttttttttgtttttttttttttttottttttttttttttttttttt')
    ('#edge-faces');
</script>
</div>

<p>处于同一位置的棱块，有两种不同的朝向可能。</p>
<div id="orientation">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttttttttttotttttttttttttttgttttttttttttttttttttt')
    ('#orientation');
</script>
</div>

<p>角块的位置也可同理表示。下图中的黄红绿棱块位于<code>URF位</code>。</p>
<div id="corner-faces">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttttttttttrttttttttttyttgttttttttttttttttttttttt')
    ('#corner-faces');
</script>
</div>

<h2 id="单层转动"><a class="header" href="#单层转动">单层转动</a></h2>
<p>试着转动魔方。魔方的所有6个面都可以转动，且每次转动都有一个面唯一对应。因此，转动记号可以沿用上节中的关于面的位置记号。</p>
<p>根据效果的不同，用三种记号来表示同一个面的转动：</p>
<ol>
<li>大写字母  （顺时针转动90°）</li>
<li>大写字母 + <code>'</code>  （逆时针转动90°）</li>
<li>大写字母 + <code>2</code>  （旋转180°）</li>
</ol>
<p>例如，<code>U</code>不仅表示顶面，也表示顶面按照顺时针旋转90°。<code>U'</code>则表示将顶面按照逆时针旋转90°。<code>U2</code>和<code>U'2</code>的效果相同，都是将顶面旋转180°。</p>
<p>使用下面的动画，点击中间的运行按键来熟悉每个转动记号，并且同时试着与你手中魔方的转动联系起来。</p>
<h3 id="u-转动"><a class="header" href="#u-转动">U 转动</a></h3>
<div id="U">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`U U' U2`)
    ('#U');
</script>
</div>

<h3 id="l-转动"><a class="header" href="#l-转动">L 转动</a></h3>
<div id="L">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`L L' L2`)
    ('#L');
</script>
</div>

<h3 id="f-转动"><a class="header" href="#f-转动">F 转动</a></h3>
<div id="F">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`F F' F2`)
    ('#F');
</script>
</div>

<h3 id="r-转动"><a class="header" href="#r-转动">R 转动</a></h3>
<div id="R">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`R R' R2`)
    ('#R');
</script>
</div>

<h3 id="b-转动"><a class="header" href="#b-转动">B 转动</a></h3>
<div id="B">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`B B' B2`)
    ('#B');
</script>
</div>

<h3 id="d-转动"><a class="header" href="#d-转动">D 转动</a></h3>
<div id="D">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`D D' D2`)
    ('#D');
</script>
</div>

<h3 id="转动序列"><a class="header" href="#转动序列">转动序列</a></h3>
<p>形如<code>R U R' U'</code>的转动记号组合，代表依次进行对应的转动操作。</p>
<div id="RUR’U’">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`R U R' U'`)
    ('#RUR’U’');
</script>
</div>

<p><code>(R U R' U')2</code>则代表将括号中的转动序列执行2次。它等价于<code>(R U R' U') (R U R' U')</code>或是<code>R U R' U' R U R' U'</code>。</p>
<div id="RUR’U’2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`R U R' U' R U R' U'`)
    ('#RUR’U’2');
</script>
</div>

<blockquote>
<p>括号有时是为了方便记忆而设置的。</p>
</blockquote>
<h3 id="逆转动"><a class="header" href="#逆转动">逆转动</a></h3>
<p><code>R U R' U'</code>的反向操作，对应的转动是<code>U R U' R'</code>。逆转动是这样得到的：先将<code>R U R' U'</code>的记号倒过来，得到<code>U' R' U R</code>，再改变每个记号的顺逆时针。当然，如果是<code>U2</code>改变为<code>U'2</code>，可以不改变写法。</p>
<p>本教程中的演示，通常从一个特定的情形(case)出发，通过一系列转动完成复原。你可以从已复原的状态出发，通过对教程提供的解法进行反向操作，得到这个特定情形。</p>
<div id="RUR’U’rev">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .case(`U R U' R'`)
    ('#RUR’U’rev');
</script>
</div>

<blockquote>
<p><code>B</code>层、<code>D</code>层和<code>L</code>层的转动方向也许有些特殊。注意所谓的顺逆时针，都是假定直接面向这个面的来观察的，而不是从你的视角的位置。例如，<code>D’</code>表示你从魔方底部向上看时，底层向逆时针旋转90°。<code>U’</code>和<code>D’</code>都代表逆时针旋转，但从你的角度来看，它们的转动方向是相反的。</p>
</blockquote>
<blockquote>
<p>注意转动记号取决于魔方当前的朝向，而不是对应中心块的颜色。如果红色中心块不在F面（前面），那么此时转动红色中心块所在面的记号就不再是<code>F</code>，而是由视野中它所在的面的朝向决定。它若在左边，那转动记号就是<code>L</code>。</p>
</blockquote>
<blockquote>
<p>应当逐步熟悉所有6类转动的手法，而不要依赖于先把要转动的面移动到自己面前，再去转这个面。即使这个面在视野之外（如转动<code>B’</code>），也不要改变魔方的朝向。</p>
</blockquote>
<h2 id="转体"><a class="header" href="#转体">转体</a></h2>
<p>转体就是魔方的整体转动。魔方可以通过三个基本的维度进行转体，因此使用所围绕的坐标轴来表示不同的转体。注意下面的<code>y</code>与<code>z</code>转动，与右手坐标系的y、z轴是相反的。</p>
<p>更简单的记忆方法是记住对应的面： <code>x</code>, <code>y</code>和 <code>z</code> 分别对应 <code>R</code>, <code>U</code>和 <code>F</code> 的方向。  例如，转体<code>x'</code> 和转动 <code>R'</code>类似，但是是所有的层都做相应转动，而不是只有R层转动。</p>
<h3 id="x-转体"><a class="header" href="#x-转体">x 转体</a></h3>
<div id="x">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`x x' x2`)
    ('#x');
</script>
</div>

<h3 id="y-转体"><a class="header" href="#y-转体">y 转体</a></h3>
<div id="y">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`y y' y2`)
    ('#y');
</script>
</div>

<h3 id="z-转体"><a class="header" href="#z-转体">z 转体</a></h3>
<div id="z">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`z z' z2`)
    ('#z');
</script>
</div>

<p>桥式解法无需转体。为了便于入门，本教程的最后一个步骤将用到一些x转体。在进阶阶段，它们可以被无需转体的方法替代。</p>
<h2 id="其他有用的记号"><a class="header" href="#其他有用的记号">其他有用的记号</a></h2>
<p>使用转动和转体记号的组合，就足以表示所有的转动了。但也有一些组合转动，在桥式解法中会非常有用：<code>M</code>、<code>r</code>。<code>E</code>、<code>S</code>在特定情形下也许也会用到。</p>
<h3 id="m转动"><a class="header" href="#m转动">M转动</a></h3>
<p><code>M</code>层指的是L、R层中间的夹层，而<code>M</code>指的是将M层转动，而保持两边的层不动。<code>M</code>层转动非常能代表桥式解法的特色。<code>M</code>层的顺逆时针的方向判断与<code>L</code>一致，较为反直觉。你也可以这样记忆：<code>M</code>字母中间的“V”指向下，这就是<code>M</code>转动的顺时针方向。</p>
<div id="M-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`M M' M2`)
    ('#M');
</script>
</div>

<blockquote>
<p>应当逐步练习一次性完成对<code>M'</code>或<code>M</code>的转动，不能用两次转动来代替。你可以使用左手无名指，从魔方下方推动<code>M'</code>。转动<code>M</code>也可通过左手无名指从魔方下方反推来完成。如果觉得比较困难，可以先用其他手指，从魔方上方将M层“压下去”。（为了<code>M</code>层转动的顺畅，建议使用一个好一些的魔方！）</p>
</blockquote>
<h3 id="r转动"><a class="header" href="#r转动">r转动</a></h3>
<p><code>r</code>转动指的是在转动R层时，连带将M层转动。因此其顺逆时针的方向判断与<code>R</code>一致，但采用小写表示双层转动。注意<code>r</code>等价于转动<code>L</code>和转体<code>x</code>的叠加，不要混淆<code>r</code>与<code>L</code>。</p>
<div id="Rw">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`r r' r2`)
    ('#Rw');
</script>
</div>

<blockquote>
<p><code>Rw</code>记号在三阶魔方中等价于<code>r</code>。该记号通常用于高阶，其中的 <code>w</code> 代表的是“wide“（宽）。如果在其他教程中遇到，知道它们是一回事就好。</p>
</blockquote>
<h3 id="不确定的转动"><a class="header" href="#不确定的转动">不确定的转动</a></h3>
<p>在本教程中，有时只能确定旋转哪一层，而具体旋转的效果要视情况而定。为了解决这类情况下表示的困难，约定采用“字母+<code>x</code>“来表示这类转动的集合。例如，用<code>Ux</code>来表示U层的所有可能转动，它可能是<code>U</code>、<code>U2</code>、<code>U’</code>，甚至<code>U0</code>（不转动）。同理有<code>Rx</code>、<code>Mx</code>、<code>rx</code>等。</p>
<h2 id="冷门记号"><a class="header" href="#冷门记号">冷门记号</a></h2>
<h3 id="e转动"><a class="header" href="#e转动">E转动</a></h3>
<p><code>E</code>层指的是U、D层中间的夹层，对应的转动为<code>E</code>转动，其顺时针转动方向与<code>U</code>一致（也和字母“E”的开口方向一致）。在桥式解法的最后一步中，有的玩家会使用双手<code>E</code>转动，处理一种称为“四心换”的情形。</p>
<div id="E">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`E E' E2`)
    ('#E');
</script>
</div>

<h3 id="s转动"><a class="header" href="#s转动">S转动</a></h3>
<p><code>S</code>层指的是F、B层中间的夹层，对应的转动为<code>S</code>转动，其顺时针转动方向与<code>F</code>一致。在单手处理“四心换”情形时，有的玩家会使用<code>S</code>转动代替<code>E</code>转动。</p>
<div id="S">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .movePeriod(1000)
    .alg(`S S' S2`)
    ('#S');
</script>
</div>

<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="两桥"><a class="header" href="#两桥">两桥</a></h1>
<p>“两桥”指的是左桥和右桥。“桥”指的是一个1×2×3的块，按照摆放的位置区分为左桥和右桥，位置相对。复原顺序是先左桥，后右桥。</p>
<p>以下是一个已经复原好的左右桥：</p>
<div id="inf1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    ('#inf1');
</script>
</div>

<blockquote>
<p>如<a href="#复原步骤的阅读">复原步骤的阅读</a>所述，每章开头的部分会给出简略复原指引，以下部分大致了解即可。你也可以跳过，在后续的章节中再详细学习。</p>
</blockquote>
<h2 id="复原步骤"><a class="header" href="#复原步骤">复原步骤</a></h2>
<p>左右桥的复原过程非常自由。一种可行的复原步骤如下：</p>
<img src="入门/两桥/images/F2B_flowchart.png" height="300" />
<p>每个桥的复原都是先完成底层的棱块，再完成两侧的棱块与角块的组合（棱角对）。</p>
<h2 id="棱角对复原"><a class="header" href="#棱角对复原">棱角对复原</a></h2>
<p>棱角对的复原是两桥部分的重点，其复原过程也较为自由。一种可行的复原过程如下：</p>
<img src="入门/两桥/images/pair_flowchart.png" height="300" />
<p>仅作为示意，实际的情形不必与上述图片完全一致。</p>
<p>左桥棱角对的复原只会比右桥的更简单。对于右桥的另一棱角对，你可以通过镜像的操作来复原。</p>
<h2 id="两类基本操作"><a class="header" href="#两类基本操作">两类基本操作</a></h2>
<p>在完成右桥时，两类基本操作<code>R Ux R'</code>与<code>R' Ux R</code>会非常有用：它们涉及与右桥空缺棱角对的位置有关的块的操作。可以将空缺棱角对的位置中的块移出，或是将位于顶层的棱角对放在空缺棱角对的位置中，完成归位。</p>
<p>它们也可以对UFR位或UBR位的角块做翻转，调整角块的朝向。通过这种方法，可以使待复原角块的白色面不朝上。例如：</p>
<img src="入门/两桥/images/RUxR&#39;.png" height="300" />
<blockquote>
<p>左右桥的具体内容将在以下两节介绍。若上面的简略复原指引已经足以让你理解并复原左右桥，你也可以跳过后面的详细介绍。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="左桥-1"><a class="header" href="#左桥-1">左桥</a></h1>
<h2 id="目标"><a class="header" href="#目标">目标</a></h2>
<p>左桥是一个1×2×3的块，其中2×3的面的颜色就称为这个桥的颜色，1×3的面的颜色称为这个桥的底的颜色。</p>
<p>左桥作为一个步骤，指的是把魔方左侧的1×2×3的块复原，作为桥式的第一步。左桥有24种可能的选择，但本教程将始终将白色底的蓝色桥作为待复原的左桥，并且后续的复原都以此为基础。</p>
<p>下面是一个白底蓝桥的形态，你可以拖动魔方以仔细观察。</p>
<div id="inf1-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttttttttrttrttttttttttttttbbbbbbtttttottottt')
    ('#inf1');
</script>
</div>

<p>你可以借鉴复原一层的思路来复原左桥，例如先组好一部分十字，再插入对应角块。但仍然推荐你通过下面的内容，理解构筑、插入棱角对的思想。这个思想也应用在右桥的复原中。我们只介绍最笨拙的左右桥复原方法。如果已经学会了如何通过组棱角对复原左桥和右桥，你可以大胆探索：是否能够走不一样的复原流程？是否可以用更少的步数完成同样的目标？</p>
<h2 id="1-复原底棱"><a class="header" href="#1-复原底棱">1 复原底棱</a></h2>
<p>第一步是将蓝色中心块与蓝白棱块合并。合并后，蓝白棱块的蓝色面应当与蓝色中心块相邻，而白色面朝下。</p>
<div id="DL-0">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttttttttttttttttttttttttttbttbttttttttttttt')
    ('#DL-0');
</script>
</div>

<p>首先调整中心块朝向。旋转魔方，使得蓝色中心块位于左面。相应地，绿色中心块会位于右面。</p>
<p>此后需要保持这样的朝向不变——始终让蓝色中心块位于左面，直到魔方完全复原。</p>
<div id="centers">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttttttttgttttttttttttttttttttttttttbttttttttttttt')
    ('#centers');
</script>
</div>

<blockquote>
<p>只需调整蓝绿中心块的位置。在桥式的最后一步（后六棱）以前，其他中心块的位置不需要关心。</p>
</blockquote>
<p>调整朝向后，将蓝色中心块与蓝白棱块合并。这步至多通过两次转动就能完成，以下是一些实例。</p>
<p><strong>例1: 改变朝向</strong></p>
<div id="DL-x2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case('x2')
    ('#DL-x2');
</script>
</div>

<p><strong>例2: D层转动</strong></p>
<div id="DL">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case('D2')
    ('#DL');
</script>
</div>

<p><strong>例3: 未归位，朝向错误</strong></p>
<div id="DL-weird">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case(`B' D`)
    ('#DL-weird');
</script>
</div>

<p><strong>例4：归位，朝向错误</strong></p>
<div id="DLflip">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case(`x F' D'`)
    ('#DLflip');
</script>
</div>

<p>或：</p>
<div id="DLflip2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttgtttttttttttttttttttttttbttbttttttttttttt')
    .case(`D' r D'`)
    ('#DLflip2');
</script>
</div>

<p>(有很多可能的解法，请自行尝试。)</p>
<p>完成后，为了不改变蓝绿块的位置，此后我们不会轻易转动L层或D层。</p>
<h2 id="2-复原一对棱角对"><a class="header" href="#2-复原一对棱角对">2 复原一对棱角对</a></h2>
<p>接下来要完成一个 <code>1x2x2</code> 方块。可以使用<code>蓝红-白</code>或<code>蓝橙-白</code>棱角对，与已有的部分组合起来。</p>
<p>以下是一个由<code>蓝红-白</code>棱角对组成的方块。</p>
<div id="square">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwttwtttttttttttrttrtttttttttttttttbbtbbtttttttttttt')
    ('#square');
</script>
</div>

<p>棱角对指的是一个棱块和一个复原状态下与之相邻的角块的组合。以下是一些已经组好的棱角对。</p>
<p><strong>蓝红-白</strong></p>
<div id="pair1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttwtttttttttttrttrttttttttttttttttbttbtttttttttttt')
    ('#pair1');
</script>
</div>

<p><strong>蓝橙-白</strong></p>
<div id="pair2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtttttttttttttttttttttttttttttttttttbttbtttttttottottt')
    ('#pair2');
</script>
</div>

<p><strong>蓝白-红</strong></p>
<div id="pair3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwttwtttttttttttrttttttttttttttttttbbttttttttttttttt')
    ('#pair3');
</script>
</div>

<p>可以看出，位于蓝白桥两侧的棱角对，前面的棱角对的侧面颜色是红，而后面的棱角对对应橙。如果在复原过程中不清楚侧面的颜色，可以转动r层(<code>rx</code>)，将白色中心块与已复原的白底棱块对齐，再根据侧面的中心块颜色判断。</p>
<p>例如，根据中心块颜色可以看出，左桥为橙白桥时，前棱角对的侧面颜色是蓝。</p>
<div id="pair4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwwtttttttttttttttttbttttttttttttttottottttttttttttt')
    ('#pair4');
</script>
</div>

<blockquote>
<p>如前面所述，白色中心块不需要始终与白底棱块对齐，因为它接下来可能随着r层和M层转动而不断移动。</p>
</blockquote>
<p>为了复原<code>蓝红-白</code>棱角对，我们采用以下步骤：</p>
<h3 id="2-1-棱块放至起始位"><a class="header" href="#2-1-棱块放至起始位">2-1 棱块放至起始位</a></h3>
<p>起始位指的是是DF位，用黑色标出。</p>
<div id="DF">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttntttttttttttntttttttttttttttttbttbttttttttttttt')
    ('#DF');
</script>
</div>

<p>这一步的目标是将蓝红棱块放在起始位，不关心其朝向。步骤如下：</p>
<p>通过<code>Ux</code>、<code>Fx</code>或<code>Bx</code>，将蓝红棱块放在M层。随后做<code>rx</code>，将棱块放入起始位。</p>
<div id="DF-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwttttttttttttbtttttttttttttttrttttbttbttttttttttttt')
    .alg(`U r'`)
    ('#DF-1');
</script>
</div>

<blockquote>
<p>如果棱块已经位于M层，显然不需要通过<code>Ux</code>、<code>Fx</code>或<code>Bx</code>调整。<code>Ux</code>的说法包含了这个意思，因为<code>Ux</code>包含<code>U0</code>。随后的<code>rx</code>也同理。这种隐含的“如果已经完成，可直接跳过”的含义，在后面会遇到很多。</p>
</blockquote>
<p><strong>特例：棱块处于DR位</strong></p>
<p>此时无法用上述流程解决，做<code>R F</code>即可。</p>
<div id="DF-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtbttttrttttttttttttttttttttttttttbttbttttttttttttt')
    .alg(`R F`)
    ('#DF-2');
</script>
</div>

<h3 id="2-2-调整角块色向"><a class="header" href="#2-2-调整角块色向">2-2 调整角块色向</a></h3>
<p>这一步的目标是调整蓝红白角块的位置。目标是将蓝红白角块放在顶层，并让白色面不朝上。</p>
<p>大多数情况下，通过<code>Rx</code>或<code>Bx</code>一步就能完成。</p>
<div id="DLF-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttrwtttbtttwtttttttrtttttttttttttttttbttbttttbtttttttt')
    .alg(`B2`)
    ('#DLF-1');
</script>
</div>

<p><strong>特例1：角块已经归位（LFD位）</strong></p>
<p>此时，无论怎样移动都会影响之前棱块的位置。此时做<code>r' F r</code>。</p>
<div id="DLF-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwttbbttttttttttwrtttttttttttttttttbrtbttttttttttttt')
    .alg(`r' F r`)
    ('#DLF-2');
</script>
</div>

<p><strong>特例2：角块位于LFU位且白色面朝上</strong></p>
<p>此时，先转<code>Ux</code>将角块放在某个<strong>翻转位</strong>上。</p>
<p>翻转位指的是UFR位或UBR位，用黑色标出。</p>
<div id="flip">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttttttttttntnttttttttnttntttttntbttbttttttttttttt')
    ('#flip');
</script>
</div>

<p>然后，作<code>R</code>或<code>R'</code>以翻转，将它放到另一个翻转位上，此时白色面便不在顶面上了。</p>
<div id="DLF-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttbtttttttttttrttttbttwtttttttttbttbtttrttttttttt')
    .alg(`U' R`)
    ('#DLF-3');
</script>
</div>

<p>或：</p>
<div id="DLF-4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttbtttttttttttrttttbttwtttttttttbttbtttrttttttttt')
    .alg(`U2' R'`)
    ('#DLF-4');
</script>
</div>

<h3 id="2-3-棱角对归位"><a class="header" href="#2-3-棱角对归位">2-3 棱角对归位</a></h3>
<p>这一步的目标是组好棱角对，并和已有的部分合并成方块。</p>
<p>首先做<code>Ux</code>，使白色面移到侧面（L面或R面），具体哪面视蓝红棱块的朝向而定。其次做<code>rx</code>或<code>Rx</code>，将棱角对正确合并。最后通常能通过一步<code>F</code>或<code>F'</code>完成归位。</p>
<div id="pair5">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttbtttttttttttrttttrttbtttttttttbttbtttwttttttttt')
    .alg(`U2' R2 F`)
    ('#pair5');
</script>
</div>

<p><strong>特例：不能直接F归位的情形</strong></p>
<div id="pair6">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttwtttrtttttttttbtbtttttttttttttttrtbttbttttttttttwtt')
    .alg(`U' r2 U2 r' F`)
    ('#pair6');
</script>
</div>

<h2 id="3-复原另一棱角对"><a class="header" href="#3-复原另一棱角对">3 复原另一棱角对</a></h2>
<p>接下来将复原剩余一对棱角对，完成左桥构建。在这里，我们需要复原<code>蓝橙-白</code>棱角对。</p>
<p>复原第一对棱角对的经验，可以几乎原封不动地用到第二组棱角对的复原中，因为它们只是关于前后做了镜像。通过下面的例子，你会看到如何用相同的办法复原<code>蓝橙-白</code>棱角对。</p>
<h3 id="3-1-棱块放至起始位"><a class="header" href="#3-1-棱块放至起始位">3-1 棱块放至起始位</a></h3>
<p>原本的<code>DF位</code>仍然作为起始位，不过这里选择了它的镜像位<code>DB位</code>。</p>
<div id="DB">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ottwttwtttttttttttrttrttttttttttttttwbbobbtttttbttbttt')
    .alg(`B' r`)
    ('#DB');
</script>
</div>

<h3 id="3-2-调整角块色向"><a class="header" href="#3-2-调整角块色向">3-2 调整角块色向</a></h3>
<p>将蓝橙白角块放在顶层，并让白色面不朝上。仍然使用了“翻转位”的方法。</p>
<div id="DLB">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tbtwttwtttttttttttrttrtttttttttttwtttbbtbbotttottttttb')
    .alg(`U R'`)
    ('#DLB');
</script>
</div>

<h3 id="3-3-棱角对归位"><a class="header" href="#3-3-棱角对归位">3-3 棱角对归位</a></h3>
<p>组好棱角对并归位。<code>Ux</code>+<code>rx</code>/<code>Rx</code> +<code>Bx'</code>能够处理大部分情况，与组第一组棱角对时的不同在于，最后的<code>Fx</code>换成了<code>Bx</code>。</p>
<div id="pair7">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tbtwttwttttttttbttrttrttttwttotttttttbbtbbttttottttttt')
    .alg(`U' R B'`)
    ('#pair7');
</script>
</div>

<p>更多的情形请自行尝试，注意复原时不要破坏已有的方块。</p>
<h2 id="不同的复原步骤"><a class="header" href="#不同的复原步骤">不同的复原步骤</a></h2>
<p>前面已经提到过，我们介绍的方法是非常死板的，实际上，桥式方法中的筑桥非常灵活，尤其是左桥，因此一定要多尝试，而不要拘泥于特定的复原步骤。下面介绍一些不同的思路。</p>
<p>左桥中的<code>1x2x2</code> 方块有前后两种选取方式。我们在复原第一个方块时，选择了位置靠前的方块，为此先复原了前棱角对（蓝红-白）。当然也可以先复原后棱角对，组好后面的方块。</p>
<p>一个<code>1x2x2</code> 方块有两组棱角对。我们先复原了蓝白棱块，再复原蓝红-白棱角对。如果先复原蓝红棱块，再复原相应的蓝白-红棱角对，当然也可行。但这样就提前选定了方块（假设不更改左桥的底色），在组第一个方块时，棱角对的选取只有一种。</p>
<p>更进一步，左桥不必一定按照“一个方块+一对棱角对”的顺序来复原。例如，“三三桥”将左桥分为两个<code>1x1x3</code>的条并分别还原。“S桥”先复原两侧的棱角对，再通过<code>S</code>层转动将中心块与蓝白棱块归位。</p>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="右桥-1"><a class="header" href="#右桥-1">右桥</a></h1>
<h2 id="目标-1"><a class="header" href="#目标-1">目标</a></h2>
<p>右桥也是一个1×2×3的块，与左桥相同，而位置与左桥相对。其底色与左桥相同，桥色相反，因此需要完成一个<strong>白底绿色桥</strong>。</p>
<p>你可以通过下面的已经完成好的右桥，观察它与上节复原的左桥的联系。</p>
<div id="inf1-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggtttrtrrtrttttttttttttbbbbbbtttotootottt')
    ('#inf1');
</script>
</div>

<h2 id="1-复原底棱-1"><a class="header" href="#1-复原底棱-1">1 复原底棱</a></h2>
<p>第一步是将将绿色中心块与绿白棱块合并、归位，并且不能破坏已经做好的左桥。</p>
<div id="DR">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgttttrttrttttttttttttttbbbbbbtttttottottt')
    ('#DR');
</script>
</div>

<p>如果绿白棱块已经和绿色中心块对齐，或绿白棱块在顶层且白色面朝上，通过 <code>Ux Rx</code>直接归位。</p>
<p><strong>例1: 直接归位的情形</strong></p>
<div id="DR1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwttttttgttttrttrttttttttttttwtbbbbbbtttttottotgt')
    .alg('U R2')
    ('#DR1');
</script>
</div>

<p>如果不能通过上面的方法归位，就将绿白棱块转动到M层，并使棱块的白色面朝上，然后再做上述操作。下面给出两个例子。</p>
<p><strong>例2: 棱块在M层</strong></p>
<p>转动<code>rx</code>或<code>Mx</code>即可。</p>
<div id="DR2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwgtttttgttttrwtrttttttttttttttbbbbbbtttttottottt')
    .alg(`M' U' R2`)
    ('#DR2');
</script>
</div>

<p><strong>例3：棱块不在M层</strong></p>
<p>转动<code>Rx Ux</code>，将绿白棱块转动到M层；再做<code>rx</code>，使棱块的白色面朝上。</p>
 
<div id="DR3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwttwtttttwgttttrttrtgttttttttttttbbbbbbtttttottottt')
    .alg(`R U r U R2`)
    ('#DR3');
</script>
</div>

<h2 id="2-复原一对棱角对-1"><a class="header" href="#2-复原一对棱角对-1">2 复原一对棱角对</a></h2>
<p>接下来要完成右桥中的一个 <code>1x2x2</code> 方块。可以使用<code>绿红-白</code>或<code>绿橙-白</code>棱角对，与已有的部分组合起来。</p>
<p>我们选择复原由<code>绿红-白</code>棱角对组成的方块，如图所示。</p>
<div id="SS">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtwggtggttttrtrrtrttttttttttttbbbbbbtttttottottt')
    ('#SS');
</script>
</div>

<p>我们介绍两类<strong>基本操作</strong>，以完成和右桥棱角对位置有关的块的处理：</p>
<h3 id="基本操作一r-ux-r"><a class="header" href="#基本操作一r-ux-r">基本操作一：<code>R Ux R'</code></a></h3>
<p>这里的<code>Ux</code>可以是<code>U</code>、<code>U'</code>或<code>U2</code>。作用是将F、R层交界位置的两个块（灰色）移动到顶层。相应地，它们的位置也会被原本在顶层的两个块（黑色）替代。</p>
 
<div id="base1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttllttlttnttttlttlttnttnttttntttttttttttttttttnt')
    .alg(`R U R'`)
    ('#base1');
</script>
</div>

 
<div id="base1-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttllttltttttttlttlnntnntttttttttttttttnttttttttt')
    .alg(`R U' R'`)
    ('#base1-2');
</script>
</div>

 
<div id="base1-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttllttltttttttlttlttttttnttnttttttttnntttttttttn')
    .alg(`R U2 R'`)
    ('#base1-3');
</script>
</div>

<h3 id="基本操作二r-ux-r"><a class="header" href="#基本操作二r-ux-r">基本操作二：<code>R' Ux R</code></a></h3>
<p>与基本操作一类似，作用是将B、R层交界的两个块移动到顶层。</p>
 
<div id="base2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttlttttttttlttlttttttttttttttttttnntttttttnttlttltttnn')
    .alg(`R' U R`)
    ('#base2');
</script>
</div>

 
<div id="base2-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttlttttttttlttlttntttttttnttnttttttntttttttttlttlttntt')
    .alg(`R' U' R`)
    ('#base2-2');
</script>
</div>

 
<div id="base2-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttlttttttttlttltttttttttnttnttnttttttttttttnnlttlttttt')
    .alg(`R' U2 R`)
    ('#base2-3');
</script>
</div>

<p>为了组好<code>绿红-白</code>棱角对并归位，我们采用以下步骤：</p>
<h3 id="2-1-棱块放至起始位-1"><a class="header" href="#2-1-棱块放至起始位-1">2-1 棱块放至起始位</a></h3>
<p>这一步的目标是将绿红棱块放在<a href="#2-1-棱块放至起始位">起始位</a>（DF位），不关心其朝向。和左桥相同，我们选择DF位作为起始位。</p>
<p>通过<code>Ux</code>将绿红棱块放在M层，然后做<code>Mx</code>，将棱块放入起始位。</p>
<div id="DF-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgttgtrttrttttttttttrtttbbbbbbtttttottottt')
    .alg(`U M`)
    ('#DF');
</script>
</div>

<p><strong>特例：棱块在右桥的位置上</strong></p>
<p>如果棱块位于RF位或RB位，使用上面介绍的基本操作，将棱块移动到顶层，此时便位于M层了。</p>
<p>对于RB位，选择基本操作二。（为什么？请回忆基本操作的功能）</p>
<div id="DF2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgrtttrttrttttttttttttttbbbbbbtttttogtottt')
    .alg(`R' U R M`)
    ('#DF2');
</script>
</div>

<blockquote>
<p>在左桥中，我们曾能够用<code>Fx</code>或<code>Bx</code>调整，将棱块移动到顶层。在右桥中不再适用。</p>
</blockquote>
<h3 id="2-2-调整角块色向-1"><a class="header" href="#2-2-调整角块色向-1">2-2 调整角块色向</a></h3>
<p>这一步的目标是调整绿红白角块的位置。目标是将绿红白角块放在顶层，并让白色面不朝上。</p>
<p>首先，将绿红白角块放在顶层。如果它不在顶层，那么一定在右桥位置上（RFD位或RBD位）。此时做一次基本操作即可。这里同样需要根据块的具体位置，以确定使用基本操作一还是二。在基本操作中，对<code>Ux</code>做适当的选择，可以避免做完后角块的白色面朝上的情况，从而一步到位。</p>
<div id="DRF-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrgwgttgttttrgrrttttttttttttttbbbbbbtttttottottt')
    .alg(`R U R'`)
    ('#DRF-1');
</script>
</div>

<p>同样的情形下，如果选择<code>U'</code>，将导致白色面朝上，需要额外做翻转。</p>
<div id="DRF-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrgwgttgttttrgrrttttttttttttttbbbbbbtttttottottt')
    .alg(`R U' R'`)
    ('#DRF-2');
</script>
</div>

<p>如果绿红白角块已经在顶层，且白色面朝上，那么需要调整角块的朝向。首先，转<code>Ux</code>将角块放在某个“翻转位”（UFR位或UBR位，见<a href="#2-2-调整角块色向">左桥-调整角块色向</a>的特例2）上。</p>
<p>如果在翻转位UFR位，做基本操作一中的<code>R U' R'</code>或<code>R U2 R'</code>。</p>
<div id="DRF-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrttgttgttttrgtrttrttwttttttttbbbbbbttgttottottt')
    .alg(`U' R U' R'`)
    ('#DRF-3');
</script>
</div>

<div id="DRF-4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrttgttgttttrgtrttrttwttttttttbbbbbbttgttottottt')
    .alg(`U' R U2 R'`)
    ('#DRF-4');
</script>
</div>

<p>如果在翻转位UBR位，做基本操作二中的<code>R' U R</code>或<code>R' U2 R</code>。</p>
<div id="DRF-5">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrttgttgttttrgtrttrttwttttttttbbbbbbttgttottottt')
    .alg(`U2 R' U R`)
    ('#DRF-5');
</script>
</div>

<blockquote>
<p>在左桥中，我们曾能够用一步<code>Rx</code>完成角块翻转。在右桥中不再适用。</p>
</blockquote>
<h3 id="2-3-棱角对归位-1"><a class="header" href="#2-3-棱角对归位-1">2-3 棱角对归位</a></h3>
<p>这一步的目标是组好棱角对，并和已有的部分合并成方块。</p>
<p>首先做<code>Ux</code>，使白色面移到侧面（L面或R面），具体哪面视绿红棱块的朝向而定。其次做<code>Mx</code>，将棱角对正确合并。</p>
<div id="pair">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwrttgttgttttrgtrttgttrttttttttbbbbbbttwttottottt')
    .alg(`U2 M2`)
    ('#pair');
</script>
</div>

<blockquote>
<p>在左桥中，我们曾用<code>rx</code>或<code>Rx</code>，让角块移动。在右桥中，我们反过来让棱块移动，以迎合角块。</p>
</blockquote>
<p>合并后有四种可能的情形。</p>
<p><strong>例1 基本操作一</strong></p>
<div id="pair1-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgttttrttrttggtrrtttttttbbbbbbttwttottottt')
    .alg(`R U' R'`)
    ('#pair1');
</script>
</div>

<p><strong>例2 双层转动的基本操作一</strong></p>
<div id="pair2-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgtwttrttrtttrrtggttttttbbbbbbtttttottottt')
    .alg(`r U r'`)
    ('#pair2');
</script>
</div>

<p><strong>例3 转化</strong></p>
<p><code>U2</code>转化为例1。另有一种情形同理转化为例2，不再列举。</p>
<div id="pair3-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtttgttgtttwrttrttttttttttttrrbbbbbbtttttottoggt')
    .alg(`U2'`)
    ('#pair3');
</script>
</div>

<h2 id="3-复原另一棱角对-1"><a class="header" href="#3-复原另一棱角对-1">3 复原另一棱角对</a></h2>
<p>接下来将复原剩余一对棱角对，完成右桥构建。在这里，我们需要复原<code>绿橙-白</code>棱角对。</p>
<p>和左桥一样，这步可以套用第一组棱角对的做法。</p>
<h3 id="3-1-棱块放至起始位-1"><a class="header" href="#3-1-棱块放至起始位-1">3-1 棱块放至起始位</a></h3>
<p>将绿橙棱块放在起始位，即<code>DF位</code>。</p>
<div id="DF3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwtwggtgggttgrtrrtrtttttttttttobbbbbbtttttootowtt')
    .alg(`R' U R M`)
    ('#DF3');
</script>
</div>

<h3 id="3-2-调整角块色向-1"><a class="header" href="#3-2-调整角块色向-1">3-2 调整角块色向</a></h3>
<p>将绿橙白角块放在顶层，并让白色面不朝上。仍然使用了“翻转位”的方法。</p>
<blockquote>
<p>与复原第一组棱角对不同的是，此时前棱角对已归位，那么应该避免选择基本操作一，因为它会破坏这组棱角对的位置。因此这时翻转位只能选择UBR位，并做基本操作二。同理，如果是先复原后面那组棱角对，那么要避免做基本操作二。</p>
</blockquote>
<div id="DRF-6">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwgwggtggttttrorrtrgttwttttttttbbbbbbttottottottt')
    .alg(`U2 R' U R`)
    ('#DRF-6');
</script>
</div>

<h3 id="3-3-棱角对归位-1"><a class="header" href="#3-3-棱角对归位-1">3-3 棱角对归位</a></h3>
<p>组好棱角对并归位。</p>
<div id="DRF-7">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wttwtwwgwggtggttttrorrtrottgttttttttbbbbbbttwttottottt')
    .alg(`U2 M2 r' U' r`)
    ('#DRF-7');
</script>
</div>

<blockquote>
<p>棱角对正确合并后，这里出现的情形和<a href="#2-3-棱角对归位-1">第一组棱角对归位</a>中的例2互为镜像，因此解法也是镜像的：<code>r</code>与<code>r'</code>对称，<code>U</code>与<code>U'</code>对称。</p>
</blockquote>
<p>更多的情形请自行尝试。</p>
<p>顺带一提，在后续的“后六棱”步骤中，将要求顶层的中心块为黄色或白色。右桥复原的最后一次转动中，你可以自由选择转<code>Rx</code>还是<code>rx</code>，以归位最后一对棱角对，因此上述目标在右桥最后一步中就可完成，从而避免后续通过<code>Mx</code>再次调整。</p>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="cmll-1"><a class="header" href="#cmll-1">CMLL</a></h1>
<h2 id="目标-2"><a class="header" href="#目标-2">目标</a></h2>
<p>这步要还原顶层的四个角块的朝向和相对位置，如图所示。CMLL的含义是：复原最后一层的角块，而不关心M层的情况(<strong>C</strong>orners (regardless of <strong>M</strong> slice) of <strong>L</strong>ast <strong>L</strong>ayer)。</p>
<p>完成后，顶层可以自由旋转，角块不必一定和左右桥对齐。</p>
<div id="CMLL-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwgggggggtgrtrrtrrtrytytttytybbbbbbbtbotootooto')
    ('#CMLL');
</script>
</div>

<p>CMLL步骤中会引入一些<strong>公式</strong>（在本教程中，指的是4步以上的转动序列）。</p>
<p>你可以选择最少的记忆量（1条公式：公式〇），但会多很多转动步数，并且需要理解如何叠加公式。</p>
<p>你也可以记忆全部9条公式（公式一~三、进阶公式一~六），避免叠加造成多余步数。</p>
<p>在后面两节的介绍中，我们将主要介绍折中的方案（3条公式：公式一~三），并顺带提及前面两种方案。然而，当你对桥式复原法较为熟练之后，建议将9条公式全部掌握。</p>
<p>我们将CMLL分为以下两个步骤：</p>
<h2 id="一-复原四角色向"><a class="header" href="#一-复原四角色向">一. 复原四角色向</a></h2>
<p>这步要将顶层的四个角块在顶层上的颜色还原正确，也就是黄色一致朝上。</p>
<div id="CMLL-o">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
    ('#CMLL-o');
</script>
</div>

<h3 id="叠加法"><a class="header" href="#叠加法">叠加法</a></h3>
<p>采用公式一、二的叠加法如下：（以下皆为俯视图）</p>
<img src="入门/cmll/images/cmll-eo_flowchart.png" height="300" />
<h3 id="公式法"><a class="header" href="#公式法">公式法</a></h3>
<p>直接复原的公式如下：</p>
<img src="入门/cmll/images/cmll-eo.png" height="450" />
<h2 id="二-复原四角相对位置"><a class="header" href="#二-复原四角相对位置">二. 复原四角相对位置</a></h2>
<p>这步将彻底完成CMLL步骤，也就是将顶层的四个角块的相对位置也还原正确。</p>
<p>公式如下：</p>
<img src="入门/cmll/images/cmll-pos_flowchart.png" height="300" />
<blockquote>
<p>CMLL的两个步骤的具体内容将在以下两节介绍。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div> <script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="四角色向"><a class="header" href="#四角色向">四角色向</a></h1>
<p>这步要将顶层的四个角块在顶层上的颜色还原正确，也就是黄色一致朝上。</p>
 
<div id="CMLL-o-1">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     ('#CMLL-o');
 </script>
 </div>

<p>共有7种未还原的情形。根据顶层四角的位置上已还原的黄色面的数量，将其分为3类：</p>
<h2 id="一个黄色面已还原"><a class="header" href="#一个黄色面已还原">一个黄色面已还原</a></h2>
<h3 id="as"><a class="header" href="#as">As</a></h3>
<p>   <img src="入门/cmll/images/cmll-as.png" width="200" height="200" /></p>
<p>上图为As形态的俯视图，特点是3个未复原的黄色面都在顶层侧面的左边。换句话说，将角块逆时针旋转120°，可以把黄色面移动到顶层。通过<code>Ux</code>将已复原的黄色面放在俯视图的左上角位置，然后完成公式：</p>
<p><strong>公式一</strong> <code>R' U' R U' R' U2 R</code></p>
 
<div id="sune">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     .case(`R' U' R U' R' U2 R`)
     ('#sune');
 </script>
 </div>

<p>这个公式的组成为：<code>(基本操作二) U' (基本操作二)</code>。（见<a href="#基本操作二r-ux-r">基本操作二</a>）可以看出，它先将右桥的后棱角对移动到顶层，再换一种方式重新插入。</p>
<p>如果你只想为整个CMLL步骤记忆一条公式，那么记忆下面的公式：</p>
<p><strong>公式〇</strong> <code>R' U L U' R U L'</code></p>
 
<div id="cmll-as">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     .case(`R' U L U' R U L'`)
     ('#cmll-as');
 </script>
 </div>

<h3 id="s"><a class="header" href="#s">S</a></h3>
<p>   <img src="入门/cmll/images/cmll-s.png" width="200" height="200" /></p>
<p>S形态的特点是3个未复原的黄色面都在顶层侧面的右边。通过<code>U</code>转动将已复原的黄色面放在俯视图的左下角位置。</p>
<p><strong>公式二</strong> <code>R U R' U R U2 R'</code></p>
 
<div id="cmll-s">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     .case(`R U R' U R U2 R'`)
     ('#cmll-s');
 </script>
 </div>

<p>这个公式的组成为：<code>(基本操作一) U (基本操作一)</code>。（见<a href="#基本操作一r-ux-r">基本操作一</a>）它对右桥的前棱角对完成重新插入。</p>
<p>如果只使用公式〇解决S形态，将已复原的黄色面放在俯视图的左上角位置，再完成：</p>
<p><code>(公式〇) U' (公式〇)</code></p>
 
<div id="cmll-s2">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     .case(`R' U L U' R U L' U' R' U L U' R U L'`)
     ('#cmll-s2');
 </script>
 </div>

<h3 id="叠加法-1"><a class="header" href="#叠加法-1">叠加法</a></h3>
<p>除As与S以外的所有形态，都能通过执行一次公式一转化为As或S形态，因此总能通过叠加前面的公式来解决: <code>Ux (公式一) Ux (公式一/公式二)</code>。<code>Ux</code>用于调整朝向。</p>
<p>当然也可以只使用公式〇解决。在上面的<code>Ux (公式一) Ux (公式一/公式二)</code>叠加方案中，将公式一替换为公式〇、公式二替换为<code>(公式〇) U' (公式〇)</code>即可。注意用于调整朝向的<code>Ux</code>会有一些变化。</p>
<h2 id="两个黄色面已还原"><a class="header" href="#两个黄色面已还原">两个黄色面已还原</a></h2>
<p>恰好两个黄色面已还原的情形有3种。其叠加法如下：无论哪种情形，保证俯视图中左上角的角块是黄色朝上的:</p>
<p>   <img src="入门/cmll/images/cmll-2.png" width="200" height="200" /></p>
<p>然后使用公式一（或公式〇），就一定转为S形态，从而能够通过公式二（或叠加公式〇）解决。</p>
<h3 id="t"><a class="header" href="#t">T</a></h3>
<p>T形态中，两个未还原的角块相邻，黄色面方向相对。</p>
<p>   <img src="入门/cmll/images/cmll-t.png" width="200" height="200" /></p>
<p>我们为叠加法给出一个具体例子。以T形态为例，首先保证俯视图中左上角的角块黄色朝上，上图已满足要求。</p>
<p>然后，执行公式一。调整朝向后再做公式二即可。</p>
 
<div id="cmll-t2">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     .case(`R' U' R U' R' U2 R U2 R U R' U R U2 R'`)
     ('#cmll-t2');
 </script>
 </div>

<p>T形态的一步复原公式为：</p>
<p><strong>进阶公式一</strong> <code>(R U R' U') (R' F R F')</code></p>
 
<div id="cmll-t">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     .case(`R U R' U' R' F R F'`)
     ('#cmll-t');
 </script>
 </div>

<h3 id="u"><a class="header" href="#u">U</a></h3>
<p>U形态中，两个未还原的角块也相邻，但黄色面方向相同。</p>
<p>   <img src="入门/cmll/images/cmll-u.png" width="200" height="200" /></p>
<p>采用<a href="#两个黄色面已还原">叠加法</a>时，上图的朝向满足起手要求。</p>
<p>U形态的一步复原公式为：</p>
<p><strong>进阶公式二</strong> <code>F (R U R' U') F'</code></p>
 
<div id="cmll-u">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     .case(`U' F R U R' U' F'`)
     ('#cmll-u');
 </script>
 </div>

<p>注意这里改变了初始朝向，使得两个黄色面朝左。</p>
<h3 id="l"><a class="header" href="#l">L</a></h3>
<p>L形态中，两个未还原的角块相对。</p>
<p>   <img src="入门/cmll/images/cmll-l.png" width="200" height="200" /></p>
<p>采用<a href="#两个黄色面已还原">叠加法</a>时，上图的朝向满足起手要求。</p>
<p>L形态的一步复原公式为：</p>
<p><strong>进阶公式三</strong> <code>(F R' F' R) (U R U' R')</code></p>
 
<div id="cmll-l">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     .case(`U F R' F' R U R U' R'`)
     ('#cmll-l');
 </script>
 </div>

<p>注意这里改变了初始朝向，使得俯视图中左下角的黄色面朝前。</p>
<h2 id="零个黄色面已还原"><a class="header" href="#零个黄色面已还原">零个黄色面已还原</a></h2>
<p>没有任何黄色面已还原的情形有2种。其<a href="#叠加法-1">叠加法</a>如下：无论哪种情形，保证俯视图中左侧的两个角块是黄色朝左的:</p>
<p>   <img src="入门/cmll/images/cmll-0.png" width="200" height="200" /></p>
<p>然后使用公式一（或公式〇），就一定转为As形态，从而能够再做一次公式一（或公式〇）解决。</p>
<h3 id="h"><a class="header" href="#h">H</a></h3>
<p>H形态中，四个未还原黄色面朝向两个方向。</p>
<p>   <img src="入门/cmll/images/cmll-h.png" width="200" height="200" /></p>
<p>对于叠加法，首先保证俯视图中左上角的角块黄色朝上，上图已满足要求。</p>
<p>然后，执行两次公式一。这里，中途不需要转动U层调整朝向。</p>
 
<div id="cmll-h2">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     .case(`R' U' R U' R' U2 R R' U' R U' R' U2 R`)
     ('#cmll-h2');
 </script>
 </div>

<p>消步后即为H形态的一步复原公式：</p>
<p><strong>进阶公式四</strong> <code>(R' U' R U') (R' U R U') R' U2 R</code></p>
 
<div id="cmll-h">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     .case(`R' U' R U' R' U R U' R' U2 R`)
     ('#cmll-h');
 </script>
 </div>

<h3 id="pi"><a class="header" href="#pi">Pi</a></h3>
<p>Pi形态中，四个未还原黄色面朝向三个方向。</p>
<p>   <img src="入门/cmll/images/cmll-pi.png" width="200" height="200" /></p>
<p>采用<a href="#零个黄色面已还原">叠加法</a>时，上图的朝向满足起手要求。</p>
<p>Pi形态的一步复原公式为：</p>
<p><strong>进阶公式五</strong> <code>F (R U R' U')2 F'</code></p>
 
<div id="cmll-pi">
 <script type="text/javascript">
   TTk.AlgorithmPuzzle(3)
     .size({width:300, height:300})
     .fc('wtwwtwwtwggggggltlrtrrtrltlytytttytybbbbbbltlotootoltl')
     .case(`F R U R' U' R U R' U' F'`)
     ('#cmll-pi');
 </script>
 </div>

<h2 id="叠加法原理选读"><a class="header" href="#叠加法原理选读">叠加法原理（选读）</a></h2>
<p>所有的情形都能通过执行一次As的复原公式（公式一），转化为As或S，也就是恰有一个黄色面已还原的情形。但我们对初始的朝向做了要求，并不是随便做一次公式一就一定能转化。那么，为什么我们提供的朝向就能奏效呢？</p>
<p>以T形态为例。它属于两个黄色面已还原的情形，我们要求俯视图中左上角的角块黄色朝上，然后执行公式一，完成转化。</p>
<p>   <img src="入门/cmll/images/cmll-t.png" width="200" height="200" /></p>
<p>对于As形态，我们要求俯视图的左上角的角块黄色面已复原，然后执行公式一，完成复原。</p>
<p>   <img src="入门/cmll/images/cmll-as.png" width="200" height="200" /></p>
<p>比较这两个俯视图，可以发现除了左下角的角块黄色面都朝下外，其他三个角块的形态都不同。因此同样执行公式一后，也会有三个角块的形态不同。既然执行结束后，As形态的四个黄色面都复原，那么T形态一定转化为恰有一个黄色面已还原，即As或S。你可以对<a href="#叠加法">叠加法</a>图中左边5个形态的朝向做验证，它们一定恰好有一个角块的形态与As相同。</p>
<p>As形态执行公式一后，不会改变左上角的角块的状态（但会改变位置）。因此T形态执行公式一后，左上角的角块的状态也不会改变，其状态与S形态的三个未复原的角块一致，因此推断出转化为S形态。同理，所有的两个黄色面已还原的情形，都将转化为S形态。</p>
<div style="break-before: page; page-break-before: always;"></div>  <script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="四角归位"><a class="header" href="#四角归位">四角归位</a></h1>
<p>这步将顶层的四个角块的相对位置也还原正确。</p>
<div id="CMLL-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwgggggggtgrtrrtrrtrytytttytybbbbbbbtbotootooto')
    ('#CMLL');
</script>
</div>

<p>观察顶面的四个侧面，有两种可能的情况：</p>
<h2 id="一侧的角块颜色相同"><a class="header" href="#一侧的角块颜色相同">一侧的角块颜色相同</a></h2>
<p>   <img src="入门/cmll/images/cmll-o1.png" width="200" height="200" /></p>
<p>如图所示，一个侧面的角块颜色相同，其余三个侧面的颜色不同。这里画出的是橙色相同。</p>
<p><code>Ux</code>将角块颜色相同的侧面转向左侧，然后完成公式：</p>
<p><strong>公式三</strong> <code>(R U R' U') R' F (R2 U' R' U') (R U R' F')</code></p>
 
<div id="cmll-o1-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwgggggggtgrtrrtrrtrytytttytybbbbbbbtbotootooto')
    .case(`R U R' U' R' F R2 U' R' U' R U R' F' U`)
    .alg(`R U R' U' R' F R2 U' R' U' R U R' F'`)
    ('#cmll-o1-1');
</script>
</div>

<p>如果你在上一节只记忆了公式〇（<code>R' U L U' R U L'</code>），并不打算记新的公式，那么<code>Ux</code>将角块颜色相同的侧面转向后侧，然后完成：</p>
<p><code>L F (公式〇) U' F' L'</code></p>
  
<div id="cmll-o1-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwgggggggtgrtrrtrrtrytytttytybbbbbbbtbotootooto')
    .case(`L F R' U L U' R U L' U' F' L' U`)
    .alg(`L F R' U L U' R U L' U' F' L'`)
    ('#cmll-o1-2');
</script>
</div>

<h2 id="每侧的角块颜色不同"><a class="header" href="#每侧的角块颜色不同">每侧的角块颜色不同</a></h2>
<p>   <img src="入门/cmll/images/cmll-o2.png" width="200" height="200" /></p>
<p>如图所示，任何一侧的角块颜色都不同。此时每一侧都是等价的，因此无需做方向调整。</p>
<p>可以叠加公式三解决：执行一次公式三（或是<code>L F (公式〇) U' F' L'</code>），使之变为上一种情形。</p>
   
<div id="cmll-o2-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwgggggggtgrtrrtrrtrytytttytybbbbbbbtbotootooto')
    .case(`F R U' R' U' R U R' F' R U R' U' R' F R F'`)
    .alg(`R U R' U' R' F R2 U' R' U' R U R' F'`)
    ('#cmll-o2-1');
</script>
</div>

<p>一步复原公式为：</p>
<p><strong>进阶公式六</strong> <code>F (R U' R' U') (R U R' F') (R U R' U') (R' F R F')</code></p>
   
<div id="cmll-o2-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wtwwtwwtwgggggggtgrtrrtrrtrytytttytybbbbbbbtbotootooto')
    .case(`F R U' R' U' R U R' F' R U R' U' R' F R F' U2`)
    .alg(`F R U' R' U' R U R' F' R U R' U' R' F R F'`)
    ('#cmll-o2-2');
</script>
</div>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="后六棱-1"><a class="header" href="#后六棱-1">后六棱</a></h1>
<h2 id="目标-3"><a class="header" href="#目标-3">目标</a></h2>
<p>这步的目标是将剩下的6个棱块（以灰色标出）复原，从而复原整个魔方。后六棱又叫做LSE(Last Six Edges)、L6E。</p>
<div id="lse">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wlwwwwwlwggggggglgrlrrrrrlrylylylylybbbbbbblbolooooolo')
    ('#lse');
</script>
</div>

<p>与CMLL类似，我们将后六棱分为两个步骤：</p>
<h2 id="一-后六棱色向"><a class="header" href="#一-后六棱色向">一. 后六棱色向</a></h2>
<p>这步(eo/4a)要将顶层和底层上剩余的块的色向还原正确，也就是白色和黄色一致朝上或朝下。下面是一个色向还原的例子。</p>
<div id="eo">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwywwywggggggolorlrrrrglgyyywwyyyybbbbbbrlrolooooblb')
    ('#eo');
</script>
</div>

<h3 id="色向复原流程"><a class="header" href="#色向复原流程">色向复原流程</a></h3>
<p>色向的复原流程如下：（图片作者：甘浩東/Anto Kam）</p>
<p>在这张图中，中心块的色向已经复原；红色棱块代表色向错误的棱块，即白色/黄色面不朝向上/下。</p>
<img src="入门/lse/images/EO_flowchart.png">
<h3 id="色向复原公式"><a class="header" href="#色向复原公式">色向复原公式</a></h3>
<p>色向直接复原的公式如下：（图片作者：Kian Mansour）</p>
<p>在这张图中，中心块的色向已经复原；紫色棱块代表色向错误的棱块。</p>
<img src="入门/lse/images/eo_cases.png" height="500" />
<p>无论采用哪一种学习路径，我们都建议结合<a href="#色向转换原理">色向转换原理</a>来辅助理解。</p>
<h2 id="二-后六棱归位"><a class="header" href="#二-后六棱归位">二. 后六棱归位</a></h2>
<p>这步要在色向还原的基础上，将剩下的6个棱块彻底复原，从而完成整个魔方的复原。可以细分为左右棱归位(ulur/4b)和后四棱(l4e/4c)。</p>
<h3 id="左右棱归位步骤"><a class="header" href="#左右棱归位步骤">左右棱归位步骤</a></h3>
<p>先将左右面位于顶层的2个棱块复原。先将它们都移动到底层，再插入：</p>
<p>在这张图中，紫色代表要插入的两个棱块，即黄蓝黄绿棱块。</p>
<img src="入门/lse/images/ulur_flowchart.png" height="300">
<h3 id="后四棱公式"><a class="header" href="#后四棱公式">后四棱公式</a></h3>
<p>复原M层的最后4个棱块：</p>
<img src="入门/lse/images/4c_cases.png" height="450">
<p>后八类情形都属于三个棱块未复原（三棱换）的情形。仅通过观察U层和F层不足以确定其形态，还需要观察D层的形态（图片左侧）。</p>
<p>三棱换的公式不必全部记忆。初学时，利用<a href="#x-转体">x转体</a>可以将它们归为两种情形，即顺时针和逆时针三棱换；进阶时，通过学习“4c入门观察法”（超出了本教程的范围），将可以预判4c的解法，而不需要做转体，也不需要对D层做额外观察。</p>
<p>如此就完成了整个魔方的复原。</p>
<div id="done">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    ('#done');
</script>
</div>

<blockquote>
<p>后六棱的两个步骤的具体内容将在以下两节介绍。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="后六棱色向"><a class="header" href="#后六棱色向">后六棱色向</a></h1>
<blockquote>
<p>这一步骤是桥式解法中最为困难的部分，请合理利用虚拟魔方下方的双箭头以观察单步转动。如果你感觉理解起来很吃力，可以在学习完“箭头”情形后，直接阅读<a href="#复原流程图">复原流程图</a>：了解具体的流程之后，再结合基本操作三~六，理解<a href="#色向转换原理">色向转换原理</a>的思想。</p>
</blockquote>
<h2 id="目标-4"><a class="header" href="#目标-4">目标</a></h2>
<p>这步要将顶层和底层上剩余的块的色向还原正确，主要解决的是剩下6个棱块的色向。这步又叫做EO (Edges Oriented)。</p>
<p>“色向”这个词在CMLL中已经提及过。所谓块的色向(orientation)，在这里指的是块沿着上下方向的朝向。例如，某个块含有黄色面，在其朝向正确时，黄色面是向上的。而在它色向正确时，黄色面不仅可以朝上，还可以朝下。</p>
<p>以下是一个色向还原正确的具体例子。你可以拖动魔方，查看底层的状态：</p>
<div id="eo-eg">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwywwywggggggolorlrrrrglgyyywwyyyybbbbbbrlrolooooblb')
    ('#eo-eg');
</script>
</div>

<p>在下图中，色向错误的棱块数量为4。（注意底层有两个）</p>
<div id="eo-eg2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wowwywwowgggggggbgryrrorryryryywyyrybbbbbbbgbowooroowo')
    ('#eo-eg2');
</script>
</div>

<p>为了直观，我们只使用红色标出上下两层中，色向错误的棱块面的位置。它不一定代表真正的红色面。</p>
<div id="eo-eg3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('trtttttrttttttttttttttttttttrtttttrttttttttttttttttttt')
    ('#eo-eg3');
</script>
</div>

<p>中心块的色向通过一步<code>Mx</code>就能解决，我们先还原它们，再处理剩下6个棱块的色向。</p>
<div id="eo-c">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wlwwywwlwgggggglllrlrrlrlllylylwlylybbbbbbllloloololll')
    .case(`M'`)
    ('#eo-c');
</script>
</div>

<blockquote>
<p>在这里，黄色中心块在顶层并不比在底层更好。</p>
</blockquote>
<p>下面的介绍中，通过<code>Ux</code>能够相互转换的情形视为同一种情形。</p>
<h2 id="四个棱块色向错误"><a class="header" href="#四个棱块色向错误">四个棱块色向错误</a></h2>
<p>首先，介绍两类基本操作：</p>
<h3 id="基本操作三-m-ux-mx"><a class="header" href="#基本操作三-m-ux-mx">基本操作三：	<code>M' Ux Mx</code></a></h3>
<p>这里，<code>Ux</code>被限制为<code>U</code>或<code>U'</code>，<code>Mx</code>也被限制为<code>M'</code>或<code>M</code>，因此共有4种组合。其作用是改变箭头一中标红位置的棱块的色向，例如：</p>
<div id="base3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttrttttttttttttttttttttrtrtrttttttttttttttttttttt')
    .alg(`M' U M'`)
    ('#base3');
</script>
</div>

<p>或者：</p>
<div id="base3-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttrttttttttttttttttttttrtrtrttttttttttttttttttttt')
    .alg(`M' U' M`)
    ('#base3-2');
</script>
</div>

<p>等等。可以看到执行完基本操作三后，4个红色面都移向了侧面，意味着其对应棱块的色向已改变。剩余两个棱块虽然没有标出，但它们的移动效果和<code>M0</code>或<code>M2</code>是一样的，因此色向不会变化。</p>
<h3 id="基本操作四-m-ux-mx"><a class="header" href="#基本操作四-m-ux-mx">基本操作四：	<code>M Ux Mx</code></a></h3>
<p>与基本操作三相比，其第一步换成了<code>M</code>，而<code>Ux</code>与<code>Mx</code>同样被限制为90°转动。其作用是改变箭头二中标红位置的棱块的色向，例如：</p>
<div id="base4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('trttttttttttttttttttttttttttttrtrtrttttttttttttttttttt')
    .alg(`M U M'`)
    ('#base4');
</script>
</div>

<p>可见，基本操作三和基本操作四能够改变特定的四个棱块的色向：3个位于顶层，1个位于底层。</p>
<h3 id="3-1箭头"><a class="header" href="#3-1箭头">“3-1”(箭头)</a></h3>
<p>箭头(Arrow)的顶层有3个色向错误的棱块，底层有1个。通过做<code>Ux</code>可调整其形态如下：</p>
<p><strong>箭头一</strong></p>
<div id="arrow1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttrttttttttttttttttttttrtrtrttttttttttttttttttttt')
    ('#arrow1');
</script>
</div>

<p><strong>箭头二</strong></p>
<div id="arrow2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('trttttttttttttttttttttttttttttrtrtrttttttttttttttttttt')
    ('#arrow2');
</script>
</div>

<p>不管哪种箭头，上面的朝向使得4个色向错误的棱块分为两对：一对左右相对，一对上下相对。</p>
<p>显然，<a href="#基本操作三m-ux-mx">基本操作三</a>和<a href="#基本操作四m-ux-mx">基本操作四</a>能直接解决箭头的情形。</p>
<p><strong>箭头一-基本操作三</strong></p>
<div id="arrow1-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`U' M' U2 M U' M U M2 U M U2 M2 U'`)
    .alg(`M' U M'`)
    ('#arrow1-1');
</script>
</div>

<p><strong>箭头二-基本操作四</strong></p>
<div id="arrow2-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M U M2 U2 M2 U2 M U2`)
    .alg(`M U M'`)
    ('#arrow2-1');
</script>
</div>

<p>“箭头”是最简单的情形。后续所有的情形，都将先转化为“箭头”情形，然后复原。</p>
<h3 id="2a-2"><a class="header" href="#2a-2">“2a-2”</a></h3>
<p>2a-2情形的含义为：“2a“代表顶层有2个色向错误的棱块，并且位置相邻(adjacent)；”-2“代表底层有2个色向错误的棱块。后边情形的命名方式都与此类似。</p>
<div id="case2a-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('trtttttrttttttttttttttttttttttrtttrttttttttttttttttttt')
    ('#case2a-2');
</script>
</div>

<p>和“箭头”相比，2a-2的顶层少了一个色向错误的棱块，而底层多了一个。</p>
<p>顶层上位于M层的两个棱块中，恰有一个色向错误。如果做<code>M2</code>，将改变M层的四个棱块的上下位置。这样，色向错误的棱块数不变（4个），而底层将恰有一个色向错误的棱块，因此转化为“箭头”情形。</p>
<div id="case2a-2-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('trtttttrttttttttttttttttttttttrtttrttttttttttttttttttt')
    .alg(`M2`)
    ('#case2a-2-1');
</script>
</div>

<p>进而可以得出一种可行的解法：</p>
<div id="case2a-2-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`U2 M U' M2 U2 M U' M' U M' U`)
    .alg(`M2 U' M' U M'`)
    ('#case2a-2-2');
</script>
</div>

<blockquote>
<p>下面我们再引入两类基本操作，以完成上下两个棱块的单独互换，并且不改变所有棱块的色向。</p>
</blockquote>
<h3 id="基本操作五-m-u2-m"><a class="header" href="#基本操作五-m-u2-m">基本操作五：	<code>M' U2 M</code></a></h3>
<p>将M层与F层（前面）交界的两个棱块（UF位、DF位）位置互换。</p>
<div id="base5">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttrtttttttttttttttttrtttttttttttttttttttttttttttt')
    .alg(`M' U2 M`)
    ('#base5');
</script>
</div>

<p>可以发现,交换位置的两个棱块的色向都没有改变，即一个正确、一个错误。</p>
<h3 id="基本操作六-m-u2-m"><a class="header" href="#基本操作六-m-u2-m">基本操作六：	<code>M U2 M'</code></a></h3>
<p>将M层与B层（后面）交界的两个棱块（UB位、DB位）位置互换。</p>
<div id="base6">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('trttttttttttttttttttttttttttttttttttttttttttttttttttrt')
    .alg(`M U2 M'`)
    ('#base6');
</script>
</div>

<p>因此，当两个互相交换的棱块有不同的色向时，这两类基本操作能将顶层色向错误的棱块数增加或减少一个，同时保证色向错误的棱块总数不变。</p>
<h3 id="2o-2"><a class="header" href="#2o-2">“2o-2”</a></h3>
<p>2o-2情形下，“2o“代表顶层有2个色向错误的棱块，并且位置相对(opposite)；”-2“代表底层有2个色向错误的棱块。</p>
<div id="case2o-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('trtttttrttttttttttttttttttttttrtrttttttttttttttttttttt')
    ('#case2o-2');
</script>
</div>

<p>与2a-2情形一样，2o-2中色向错误的棱块数也是4个。对于2a-2，我们使用<code>M2</code>让顶层和底层的四个棱块两两互换，从而将顶层色向错误的棱块数改变为3，转化为“箭头”。这里用同样的办法就不能奏效了。</p>
<p>对于2o-2情形，可以做<a href="#基本操作五-m-u2-m">基本操作五</a>或<a href="#基本操作六-m-u2-m">六</a>转换为箭头。下面的演示以基本操作六为例：在B面（后面）上，一个底层色向错误的棱块与一个顶层色向正确的棱块交换，便转化为“箭头”。</p>
<div id="case2o-2-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('trtttttrttttttttttttttttttttttrtrttttttttttttttttttttt')
    .alg(`M U2 M'`)
    ('#case2o-2-1');
</script>
</div>

<p>一种可行的解法如下：</p>
<div id="case2o-2-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M U2 M' U2 M' U' M U2 M2 U M2 U'`)
    .alg(`M U2 M' U2 M' U M'`)
    ('#case2o-2-2');
</script>
</div>

<h3 id="4-0"><a class="header" href="#4-0">“4-0”</a></h3>
<p>4-0情形下，顶层有4个色向错误的棱块，而底层没有。</p>
<p>可以想象，<code>M2</code>就能将4-0转为2o-2的情形。因此将2o-2解法的第一步由<code>M</code>改为<code>M'</code>，就能解决这类情形。</p>
<div id="case4-0">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttttttttttttttttttttttrtrtrtrttttttttttttttttttt')
    ('#case4-0');
</script>
</div>

<div id="case4-0-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M' U2 M' U2 M' U' M U2 M2 U M2 U'`)
    .alg(`M' U2 M' U2 M' U M'`)
    ('#case4-0');
</script>
</div>

<h2 id="两六个棱块色向错误"><a class="header" href="#两六个棱块色向错误">两/六个棱块色向错误</a></h2>
<h3 id="色向转换原理"><a class="header" href="#色向转换原理">色向转换原理</a></h3>
<p>我们已经展示了恰有4个色向错误的棱块的情形，转化为<a href="#3-1箭头">“箭头”</a>情形的办法，即通过<a href="#基本操作五-m-u2-m">基本操作五</a>、<a href="#基本操作六-m-u2-m">六</a>或<code>M2</code>来改变上下面中色向错误的棱块的分配。</p>
<p>对于色向错误的棱块数不为4的情形，其统一的复原步骤如下：</p>
<ol>
<li>
<p>通过至多两次<a href="#基本操作三-m-ux-mx">基本操作三</a>、<a href="#基本操作四-m-ux-mx">四</a>，将色向错误的棱块总数转为4个。通过精心选择要执行的基本操作，魔方可以直接转为“箭头”情况。如果没能转为“箭头”，则使用基本操作五、六再做转换。</p>
</li>
<li>
<p>通过基本操作三或四，解决“箭头”情况，完成色向复原。</p>
</li>
</ol>
<blockquote>
<p>基本操作三或四能够同时改变4个棱块的色向。除非这四个位置恰好有两个色相错误的棱块，否则基本操作三、四一定会改变色向错误的棱块总数。例如，如果这四个位置有1个色向错误，那么执行完后这四个棱块变为3个色向错误，总数量加2。</p>
</blockquote>
<p>共有5类情况，一一介绍：</p>
<h3 id="2a-0"><a class="header" href="#2a-0">“2a-0”</a></h3>
<p>“2a”代表顶层色向错误的两个棱块位置相邻。</p>
<p>执行<a href="#基本操作三-m-ux-mx">基本操作三</a>如<code>M' U M'</code>后，色向正确的棱块总数增加2，转化为“箭头”情形。</p>
<div id="case2a-0">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttttttttttttttttttttttttrtttrttttttttttttttttttt')
    ('#case2a-0');
</script>
</div>

<div id="case2a-0-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`U M U2 M U' M U M' U2 M U' M'`)
    .alg(`M' U M' U2 M' U M'`)
    ('#case2a-0');
</script>
</div>

<h3 id="2o-0"><a class="header" href="#2o-0">“2o-0”</a></h3>
<p>“2o”代表顶层色向错误的两个棱块位置相对。</p>
<p>可通过<a href="#基本操作三-m-ux-mx">基本操作三</a>如<code>M' U M</code>转换。</p>
<div id="case2o-0">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('ttttttttttttttttttttttttttttrtttttrttttttttttttttttttt')
    ('#case2o-0');
</script>
</div>

<div id="case2o-0-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M2 U M U M U' M' U M U M2`)
    .alg(`M' U M U' M' U M'`)
    ('#case2o-0');
</script>
</div>

<h3 id="0-2"><a class="header" href="#0-2">“0-2”</a></h3>
<p>可通过<a href="#基本操作三-m-ux-mx">基本操作三</a>如<code>M' U M'</code>转换。</p>
<div id="case0-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('trtttttrtttttttttttttttttttttttttttttttttttttttttttttt')
    ('#case0-2');
</script>
</div>

<div id="case0-2-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M' U' M' U M U M U M U2 M'`)
    .alg(`M' U M' U' M U M'`)
    ('#case0-2');
</script>
</div>

<p>由于0-2与2o-0只差一步<code>M2</code>，也可以将2o-0解法的第一步由<code>M'</code>替换为<code>M</code>。</p>
<h3 id="1-1"><a class="header" href="#1-1">“1-1”</a></h3>
<p>有两种情形。</p>
<p>以下朝向下，可执行<a href="#基本操作四-m-ux-mx">基本操作四</a>如<code>M' U M</code>转换：</p>
<div id="case1-1-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('trttttttttttttttttttttttttttrttttttttttttttttttttttttt')
    ('#case1-1-1');
</script>
</div>

<div id="case1-1-1-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`U M' U' M' U2 M U M U`)
    .alg(`M U M' U M U M'`)
    ('#case1-1-1');
</script>
</div>

<p>另一种的转化方法类似（<a href="#基本操作三-m-ux-mx">基本操作三</a>，如<code>M' U M</code>）:</p>
<div id="case1-1-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('tttttttrttttttttttttttttttttttttttrttttttttttttttttttt')
    ('#case1-1-3');
</script>
</div>

<div id="case1-1-3-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`M' U' M' U2 M U M U M U' M'`)
    .alg(`M' U M U M' U M'`)
    ('#case1-1-3');
</script>
</div>

<h3 id="4-2"><a class="header" href="#4-2">“4-2”</a></h3>
<p>4-2的所有6个棱块的色向都错误。</p>
<p>无论是执行<a href="#基本操作三-m-ux-mx">基本操作三</a>还是<a href="#基本操作四-m-ux-mx">基本操作四</a>，都会导致顶层色向错误的棱块数量减3、底层减1，因此只能先转化为1-1情形，再进一步转化为“箭头”。以下解法首先做基本操作四<code>M U M'</code>。</p>
<div id="case4-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('trtttttrttttttttttttttttttttrtrtrtrttttttttttttttttttt')
    ('#case4-2');
</script>
</div>

<div id="case4-2-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`U' M' U' M' U2 M U M U M' U' M' U M2 U`)
    .alg(`M U M' U2 M' U M U M' U M'`)
    ('#case4-2');
</script>
</div>

<p>另有一种简便解法：<code>R U' r' U' M' U r U r</code>。</p>
<div id="case4-2-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`U' M' U' M' U2 M U M U M' U' M' U M2 U`)
    .alg(`R U' r' U' M' U r U r'`)
    ('#case4-2-3');
</script>
</div>

<h2 id="复原流程图"><a class="header" href="#复原流程图">复原流程图</a></h2>
<p>直观的色向复原流程图（作者：甘浩東/Anto Kam）如下：</p>
<img src="入门/lse/images/EO_flowchart.png">
<p>在这张图中，红色棱块代表色向错误的棱块。图中无法看到DB位置棱块的色向，但请记住：色向错误的棱块总数一定为偶数。因此从图中就能足够推断它的色向情况。</p>
<p>不要去硬记每种情形的完整转换公式。应当将复原流程与基本操作三~六的功能联系起来，理解<a href="#基本操作三-m-ux-mx">基本操作三</a>、<a href="#基本操作四-m-ux-mx">四</a>是如何改变色向错误的棱块总数，<a href="#基本操作五-m-u2-m">基本操作五</a>、<a href="#基本操作六-m-u2-m">六</a>是如何改变色向错误的棱块的分布的，如同我们在<a href="#色向转换原理">色向转换原理</a>中所介绍的那样。</p>
<p>注意每次转换完成后，还需要通过<code>Ux</code>，调整为图中相应的朝向。</p>
<div style="break-before: page; page-break-before: always;"></div><script type="text/javascript" src="/twistysim.js"></script>
<style type="text/css" rel="stylesheet">
/* modifies the opacity of the cube wireframe */
.ttk-shp-poly {
    stroke-opacity: 0.3;
}
</style>
<h1 id="后六棱归位"><a class="header" href="#后六棱归位">后六棱归位</a></h1>
<h2 id="目标-5"><a class="header" href="#目标-5">目标</a></h2>
<p>这步要<strong>在色向还原的基础上</strong>，将剩下的6个棱块彻底复原，从而完成整个魔方的复原。分为两个阶段：</p>
<p>先将左右面位于顶层的2个棱块复原，并将M层的中心块对齐，剩下最后M层的4个棱块。</p>
<div id="l4e">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wlwwwwwlwgggggggggrlrrrrrlrylyyyyylybbbbbbbbbolooooolo')
    ('#l4e');
</script>
</div>

<p>再复原最后4个棱块。</p>
<h2 id="1-左右棱"><a class="header" href="#1-左右棱">1 左右棱</a></h2>
<h3 id="1-1-左右棱置底"><a class="header" href="#1-1-左右棱置底">1-1 左右棱置底</a></h3>
<p>为了复原左右面位于顶层的2个棱块(ULUR)，我们先将要归位的黄蓝、黄绿棱块都放到底层。</p>
<p>以下是一个具体例子。你可以拖动魔方，主要查看底层的状态：</p>
<div id="ulur">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wywwwwwywggggggglgrbrrrrrlrylylylylybbbbbbblbogooooolo')
    ('#ulur');
</script>
</div>

<p>还原方法如下：</p>
<p>如果恰好有一个黄蓝或黄绿棱块在顶层：</p>
<p>先<code>Ux</code>将该棱块放在M层，并且保证其下方不是黄蓝或黄绿棱块。再做<a href="#基本操作五-m-u2-m">基本操作五</a>或<a href="#基本操作六-m-u2-m">六</a>，完成上下棱块的交换，将其放在底层。</p>
<p>这个例子通过基本操作六，将黄绿棱块从UR位移到DB位。</p>
<div id="ulur-1">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wywwwwwywggggggglgrbrrrrrlrylylylylybbbbbbblbogooooolo')
    .case(`U' M U2 M'`)
    ('#ulur-1');
</script>
</div>

<p>如果黄蓝、黄绿棱块都在顶层：</p>
<p>通过<code>Ux</code>将其中一个棱块放在M层，再<code>M2</code>将其放在底层。这样，至多有一个棱块仍然留在顶层，转化为上一种情形。</p>
<p>这个例子将黄绿棱块移到DB位，然后再通过基本操作五，将黄蓝棱块从UR位移到DF位。</p>
<div id="ulur-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wlwwwwwlwgggggggbgrlrrrrrgryyylyyylybbbbbbblbolooooolo')
    .alg(`M2 U M' U2 M`)
    ('#ulur-2');
</script>
</div>

<p>这样就将两个棱块都放在底层了，两个棱块谁在前并不重要，但色向必须正确。</p>
<h3 id="1-2-左右棱归位"><a class="header" href="#1-2-左右棱归位">1-2 左右棱归位</a></h3>
<p>左右棱都放到底层后，做<code>Ux</code>调整顶层角块的姿态，然后做<code>M2</code>，将黄蓝、黄绿棱块分别与对应的角块合并。</p>
<div id="ulur-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wywwwwwywggggggglgrbrrrrrlrylylylylybbbbbbblbogooooolo')
    .alg(`U M2`)
    ('#ulur-3');
</script>
</div>

<p>最后做<code>Ux Mx</code>，将左右棱块与M层中心块彻底归位。</p>
<div id="ulur-4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wlwwywwlwggggggolorlrrorgggyyylwlyyybbbbbbrlroloorobbb')
    .alg(`U' M2`)
    ('#ulur-4');
</script>
</div>

<h2 id="2-后四棱"><a class="header" href="#2-后四棱">2 后四棱</a></h2>
<p>这步完成最后4个棱块的复原（L4E）。</p>
<p>完成左右面的复原后，魔方的形态变得更加对称了。你可以自由地做一些<a href="#x-转体">x转体</a>，也可以自由尝试一些M层操作与<code>U2</code>的组合。</p>
<p>下面介绍一些简单的4步操作，来完成魔方最终的复原。</p>
<h3 id="三棱换"><a class="header" href="#三棱换">三棱换</a></h3>
<p>这种情况下，对齐中心块后，恰好有3个棱块未复原，而1个M层棱块已经复原。</p>
<p>首先做x转体，使复原的棱块位于DF位上。</p>
<p>下图中，我们将已复原的黄红棱块转到DF位上。</p>
<div id="L4E">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wywwwwwwwgggggggggrorrrrrrryyyyyyywybbbbbbbbboooooooro')
    .alg(`x'`)
    ('#L4E');
</script>
</div>

<p>进一步观察：</p>
<p>如果UF位的棱块颜色与两侧中心块的颜色都相反，做<code>U2 M U2 M'</code>（即<code>U2</code>+ 基本操作六）。</p>
<p>如图，UF位的白红棱块，两侧的中心块分别为黄、橙，满足要求。</p>
<div id="L4E-2">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('rrrrrrrrrgggggggggyyyyyyyyyooooooooobbbbbbbbbwwwwwwwww')
    .case(`U2 M U2 M'`)
    ('#L4E-2');
</script>
</div>

<p>如果UF位的棱块颜色仅与前面中心块的颜色相反，做<code>M U2 M' U2</code>（即基本操作六+<code>U2</code>）。</p>
<div id="L4E-3">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('rrrrrrrrrgggggggggyyyyyyyyyooooooooobbbbbbbbbwwwwwwwww')
    .case(`M U2 M' U2`)
    ('#L4E-3');
</script>
</div>

<p>你也可以尝试：如何不依赖转体，仅使用<code>U2</code>和M层操作的组合来复原。不转体的完整公式可参考<a href="#后四棱公式">后四棱公式</a>。</p>
<blockquote>
<p>对于后四棱，有经验的桥式玩家不会依赖公式复原，而会通过提前观察相应的块的变化，完成对整个后四棱步骤的预判。这些观察方法包括4c入门观察法、DFDB观察法、BU观察法等。</p>
</blockquote>
<h3 id="四心换"><a class="header" href="#四心换">四心换</a></h3>
<p>这种情况下，对齐中心块后，有四个面呈“H”型。做<code>E2 M' E2 M'</code>。</p>
<div id="L4E-5">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('wwwwwwwwwgggggggggrrrrrrrrryyyyyyyyybbbbbbbbbooooooooo')
    .case(`E2 M' E2 M'`)
    ('#L4E-5');
</script>
</div>

<blockquote>
<p>之所以笼统地称这类情况为“四心换”，是因为做<code>M2</code>后，除了4个中心块外的所有块都已复原。</p>
</blockquote>
<h3 id="h-1"><a class="header" href="#h-1">“H”</a></h3>
<p>这种情况下，对齐中心块后，四个面已经复原，而剩余两个相对的面呈“H”型。将一个H型的面放在F面，做<code>U2 M2 U2 M2</code>。</p>
<div id="L4E-4">
<script type="text/javascript">
  TTk.AlgorithmPuzzle(3)
    .size({width:300, height:300})
    .fc('rrrrrrrrrgggggggggyyyyyyyyyooooooooobbbbbbbbbwwwwwwwww')
    .case(`x' U2 M2 U2 M2`)
    ('#L4E-4');
</script>
</div>

<p>至此，魔方的六面都已经复原，大功告成！</p>
<p>你可以反复练习，直到能够不依赖教程而独立复原。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="关于本教程"><a class="header" href="#关于本教程">关于本教程</a></h1>
<h2 id="作者"><a class="header" href="#作者">作者</a></h2>
<ul>
<li><a href="https://github.com/Aqua-water">Aqua-water</a></li>
</ul>
<h2 id="参考工作"><a class="header" href="#参考工作">参考工作</a></h2>
<p>本教程参考了许多工作：</p>
<ul>
<li>
<p><a href="https://tutorial.rouxers.com/">Roux Tutorial by Anto Kam</a></p>
</li>
<li>
<p><a href="https://book.rouxers.com/intro.html">The Roux Reader by onionhoney, Anto Kam, etc.</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/playlist?list=PLBHocHmPzgIjnAbNLHDycgaCP5IqiwnU9">Roux Tutorial by Kian Mansour</a></p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV1At411n7ec/?spm_id_from=333.337.search-card.all.click&amp;vd_source=fb895e67af7851b9802f3e610083cd44">桥式入门教程-随风又见面了</a></p>
</li>
<li>
<p><a href="http://bbs.mf8-china.com/forum.php?mod=viewthread&amp;tid=31908">用一个公式还原魔方-时富军</a></p>
</li>
<li>
<p><a href="https://cube.rider.biz/visualcube.php">VisualCube by Rider</a></p>
</li>
<li>
<p><a href="https://cube.rider.biz/twistysim.html">TwistySim by Rider</a></p>
</li>
</ul>
<p>非常感谢前辈们的付出。</p>
<h2 id="让教程变得更好"><a class="header" href="#让教程变得更好">让教程变得更好</a></h2>
<ul>
<li>
<p>你可以在<a href="https://github.com/Aqua-water/Roux-Beginners/issues/new">Github</a>上提出任何的改进建议！</p>
</li>
<li>
<p>成为作者：如果你想成为源项目的开发者，为这份教程增加新的内容，可以参考这份简单的<a href="https://github.com/Aqua-water/Roux-Beginners/blob/main/README.md">指引</a>，并在<a href="https://github.com/Aqua-water/Roux-Beginners/pulls">Github</a>上提交请求。</p>
</li>
<li>
<p>也可以通过邮件联系原作者：t152826615@gmail.com</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
